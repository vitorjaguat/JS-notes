<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
        integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

    <link href="app.css" rel="stylesheet" type="text/css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Nunito:wght@200;400;700&family=Open+Sans:wght@400;700&family=Poppins:ital,wght@0,400;1,100&display=swap"
        rel="stylesheet">
    <title>JS NOTES</title>

</head>

<body>
    <h1>Javascript Notes</h1>
    <h2>Primitive Types</h2>
    <h3>Numbers</h3>
    <p>1, 2, 2.4, 3.333333, -343, -3.343434 are all numbers.</p>
    <div class="alert-info">To transform non-numbers into numbers, use Number("55") or +"55", it will give //55 as a
        result.</div>
    <h4>NaN</h4>
    <p>Stands for "not a number", means everything which is not a number. Includes any division by 0.</p>
    <h3>Boolean</h3>
    <p>true</p>
    <p>false</p>
    <h3>String</h3>
    <p>String is any text content. Must be put inside of "" or ''.</p>
    In JavaScript, there are 3 types of quotes.
    <br>Double quotes: "Hello".
    <br>Single quotes: 'Hello'.
    <br>Backticks: `Hello`.
    <br>Double and single quotes are “simple” quotes. There’s practically no difference between them in JavaScript.
    <br>Backticks are “extended functionality” quotes. They allow us to embed variables and expressions into a string by
    wrapping them in ${…}. The expression inside ${…} is evaluated and the result becomes a part of the string. We can
    put anything in there: a variable like name or an arithmetical expression like 1 + 2 or something more complex.
    <div class="alert-info">Use \ to "escape" or skip one character in the string. It is used when we want to write ' or
        " as part of the inner part of a string. Eg:
        <br>const bigmouth = 'I\'ve got no right to take my place...';
        <br>console.log(bigmouth);
    </div>
    <h4>Index[]</h4>
    myName = "Vitor"<br>
    myName[2]<br>
    //"i"<br>
    myName[0]<br>
    //"V"<br>
    myName[9]<br>
    //undefined<br>
    <h4>.length</h4>
    <p>Tells the total number of characters in that string.</p>
    myName = "Vitor"<br>
    myName.length<br>
    //5<br>
    <h4>Concatenation ""+""</h4>
    myName = "Vitor"<br>
    myLastname = "Jaguat"<br>
    myName + myLastname<br>
    //"VitorJaguat"<br>
    myName + " " + myLastname<br>
    //"Vitor Jaguat"<br>
    myName + 1<br>
    //"Vitor1" <span class="red">(transforms the number into a string)</span>


    <h3>Null</h3>
    <h3>Undefined</h3>
    <h3>Symbol</h3>
    <h3>BigInt</h3>

    <h2>Variables & let</h2>
    let myAge = 39<br>
    myAge = 39<br>
    let myName = "Vitor"<br>
    myName = "Vitor"<br>
    <br>
    <h3>Basic operations</h3>
    myAge + 2 <br>
    // 41 <br>
    myAge - 3 <br>
    // 37 <br>
    myAge * 2 <br>
    // 78 <br>
    myAge / 2 <br>
    // 19,5 <br>
    myAge ** 2 <br>
    // 1521 <br>
    myAge % 2 <br>
    // 1 <br>
    % stands for "module", "mod".<br>
    <br>
    <h3>Changing the Variable's value</h3>
    myAge += 1 <span class="red">adds to the Variable</span> <br>
    myAge -= 1 <span class="red">subtracts from the Variable</span><br>
    myAge *= 2 <span class="red">multiplies the Variable for...</span><br>
    myAge ++ <span class="red">adds 1 to the Variable</span><br>
    myAge -- <span class="red">subtracts 1 from the Variable</span>
    <h3>const & var</h3>
    <p>const boilingPointC = 100</p>
    <p>const boilingPointF = 212</p>
    <p>var myAge = 39 <span class="red">the same as </span>let myAge = 39</p>
    <p><i>const</i>cannot be altered in that document.</p>

    <h2>String Methods</h2>
    <p>myName = "Vitor" <br>
        myName.toUpperCase()<br>
        //"VITOR"
        myName.toLowerCase()<br>
        //"vitor"<br>
    </p>
    <p>myName = " Vitor "<br>
        myName.trim() <br>
        //"Vitor"<br>
        myName.toUpperCase().trim()<br>
        //"VITOR"
    </p>
    <h3>String Methods with Arguments</h3>
    <p>.indexOf('argument') indicates the first occurance of a value.</p>
    <p>let tvShow = "catdog"<br>
        tvShow.indexOf('cat')
        <br>//0
        <br>tvShow.indexOf('dog')
        <br>//3
        <br>tvShow.indexOf('z')
        <br>//-1 <span class="red">(not found)</span>
    </p>
    <p>.slice('argument') cuts the string before (and after) the index given in the argument.</p>
    <p>"haha that is so funny!".slice(5)
        <br>//"that is so funny!"
        <br>"haha that is so funny!".slice(5,9)
        <br>//"that"
        <br>"haha that is so funny!".slice(-6)
        <br>//"funny!"
    </p>
    <p>
        .replace(argument,argument) replaces parts of the string for another.
        <br>let msg = "haha that is so funny!"
        <br>msg.replace('haha','lolololo')
        <br>//"lolololo that is so funny!"
        <br>msg.replace('h','H')
        <br>//"Haha that is so funny!"
        <br>msg.replaceAll('h','H')
        <br>//"HaHa tHat is so funny!"

    </p>
    <p>.repeat(argument) repeats the string by the number of times specified in the argument.
        <br>"lol".repeat(3)
        <br>//"lollollol"
    </p>

    <h3>String Template Literals</h3>
    let product = 'Artichoke';
    <br>let price = '2.25';
    <br>let qty = '5';
    <br>"You bought " + qty + " " + product + ". Total is: " + price * qty
    <br>//"You bought 5 Artichoke. Total is: 11.25"
    <br>
    <p>
        An expression is written between backticks `expression`.</p>
    'hello ${1+2+9}'<br>
    //"hello ${1+2+9}"<br>
    `hello ${1+2+9}`<br>
    //"hello 12"<br><br>

    <br>"You bought " + qty + " " + product + ". Total is: $" + price * qty
    <br>//"You bought 5 Artichoke. Total is: $11.25"
    <br>`You bought ${qty} ${product}. Total is: $${price*qty}`
    <br>//"You bought 5 Artichoke. Total is: $11.25"
    <br>`You bought ${qty} ${product.toUpperCase()}. Total is: $${price*qty}`
    <br>//"You bought 5 ARTICHOKE. Total is: $11.25"

    <h3>null & undefined</h3>
    <p><i>null</i> is the intentional absence of any value. Must be assigned.
        <br>let loggedInUser = null;
        <br>a user logs in...
        <br>loggedInUser = 'Alan Lefter'
    </p>
    <p><i>undefined</i> are variables that do not have an assigned value. Don't need to be assigned.
        <br>'hello'[99]
        <br>//undefined <span class="red">there is no value assigned to index 99 in the string 'hello'</span>
    </p>

    <h3>Math object</h3>
    <p>Contains properties and methods for mathematical constants and functions</p>
    <br>Math.PI
    <br>//3.1415...
    <br>Math.round(4.9)
    <br>//5
    <br>Math.abs(-456)
    <br>//456
    <br>Math.pow(2,5) <span class="red">raises 2 to the 5th power</span>
    <br>//32
    <br>Math.floor(3.9999) <span class="red">removes decimal</span>
    <br>//3
    <br>
    <br>Math.random() <span class="red">gives a ramdom number between 0 and 1</span>
    <br>//0.738848964398392
    <br>Math.random() * 5 <span class="red">to give a number between 0 and 5</span>
    <br>//2.378789833
    <br>Math.floor(Math.random()*5) + 1 <span class="red">to give an integer between 1 and 5</span>
    <br>//3
    <br>Math.floor(Math.random()*10) + 1 <span class="red">to give an integer between 1 and 10</span>
    <br>Math.floor(Math.random()*3) + 20 <span class="red">to give an integer between 20 and 22</span>
    <br>//21
    <br>Math.floor(Math.random() * 6) + 1; <span class="red">to give an integer between 1 and 6 (ROLLING A DICE!)</span>
    <br>//5
    <p>
        let die1 = Math.floor(Math.random() * 6) + 1;
        <br>let die2 = Math.floor(Math.random() * 6) + 1;
        <br>let roll = `You rolled a ${die1} and a ${die2}. They sum to ${die1+die2}`
        <br>roll;
        <br>//"You rolled a 6 and a 4. They sum to 10"
    </p>

    <h2>Decision Making: Boolean Logic</h2>
    <h3>Comparisons</h3>
    <p>> greater than</p>
    <br>1 > 3
    <br>//false
    <br>1 &lt; 3 <br>//true
    <br>-1 &lt;= -1 <br>//true
    <br>== checks for equality of value, but not equality of type; it coerces both values to the same type and compares
    them; this can lead to unexpected results!
    <br>1 == 1;
    <br>//true
    <br>1 == '1';
    <br>//true
    <br>'b'=='c';
    <br>//false
    <br>0 == '';
    <br>//true
    <br>true == false;
    <br>//false
    <br>0 == false;
    <br>//true
    <br>null == undefined;
    <br>//true
    <br>
    <br>=== checks for equality of value and type.
    <br>5 === 5;
    <br>//true
    <br>2 === '2';
    <br>//false
    <br>false === 0;
    <br>//false
    <br>same applies to != and !==
    <br>1 != '1'
    <br>//false
    <br>1 !== '1'
    <br>//true
    <br>Always use === and !==

    <h2>console.log()</h2>
    <p>Prints arguments to the console.</p>
    <p>alert("Do you want notifications from this website?")
        <br>will exhibit a message in a popup on the page.
    </p>
    <p>prompt("Please enter a number")
        <br>will exhibit a popup asking for an input on the page.
        <br>let userInput = prompt("Please enter a number") <span class="red">then user entered number 97</span>
        <br>userInput
        <br>//"97" <span class="red">this is a string</span>
        <br>userInput + 1
        <br>//"971"
        <br>parseInt(userInput)
        <br>97 <span class="red">this is a number</span>
        <br>parseInt(userInput) + 1
        <br>//98
    </p>
    <h2>Running JavaScript from a script!</h2>
    <p>create a .js file on VSCode</p>
    <br>on HTML head <span class="red">actually it is better to put it at the end of body element</span>:
    <pre>
            <code>
                &lt;script src="app.js"&gt;&lt;/script&gt;
            </code>
        </pre>
    <h2>Conditionals</h2>
    <h3>if statement</h3>
    <p>Only runs code if given condition is true.</p>
    let rating = 3;
    <br>if (rating===3) {
    console.log("YOU ARE A SUPERSTAR!");
    }
    <br><br>
    <pre><code>
            let random = Math.random();
            if (random < 0.5) { 
                console.log("YOUR NUMBER IS LESS THAN 0.5!") 
                console.log(random); 
            } 
            if (random>= 0.5) {
                console.log("YOUR NUMBER IS GREATER THAN 0.5!")
                console.log(random);
                }</code></pre>

    <br><br>

    <h3>else if</h3>
    <p>If not the first thing, maybe this other thing?</p>
    <pre><code>
                const dayOfWeek = 'Monday';
                if (dayOfWeek==='Monday') {
                    console.log("UGHH I hate Mondays!")
                } else if (dayOfWeek==='Saturday') {
                    console.log("YAY I love Saturdays!")
                } else if (dayOfWeek==='Sunday') {
                    console.log("YAY I looove Sundays!")
                }
            </code></pre>
    0-5 FREE
    <br>5-10 CHILD $10
    <br>10-65 ADULT $20
    <br>65+ SENIOR $10
    <pre><code>
                const age = 8;
                if (age < 5) {
                    console.log("FREE")
                } else if (age < 10) {
                    console.log("CHILD $10")
                } else if (age < 65) {
                    console.log("ADULT $20")
                } else if (age >= 65) {
                    console.log("SENIOR $10")
                }
            </code></pre>

    <h3>else</h3>
    <p>If nothing else was true, do this...</p>
    <pre><code>
                let dayOfWeek = prompt('What day is today?');
                if (dayOfWeek==='Monday') {
                    console.log("UGHH I hate Mondays!")
                } else if (dayOfWeek==='Saturday') {
                    console.log("YAY I love Saturdays!")
                } else if (dayOfWeek==='Sunday') {
                    console.log("YAY I looove Sundays!")
                } else {
                    console.log("MEH");
                }
            </code></pre>
    <pre><code>

            </code></pre>
    let random = Math.random();
    if (random < 0.5) { console.log("YOUR NUMBER IS LESS THAN 0.5!") console.log(random); } else { console.log("YOUR
        NUMBER IS GREATER THAN 0.5!") console.log(random); } </code>
        </pre>

        <h3>Nesting Conditionals</h3>
        Eg:
        <pre><code>const password = prompt("Please enter a new password");
            </code></pre>

        Password must be 6+ characters:
        <pre><code>
            if(password.length >= 6) {
                console.log("Long enough password!")
            } else {
                console.log("Password too short! Must be 6+ characters")
            }
                </code></pre>
        Password cannot include space:
        <pre><code>
                    if (password.indexOf(' ') === -1) {
                        console.log("Good job! No space.")
                    } else {
                        console.log("Cannot contain spaces.")
                    }
                </code></pre>
        Nesting the second conditional inside of the first:
        <pre><code>
                    if(password.length >= 6) {
                        if (password.indexOf(' ') === -1) {
                            console.log("Valid password! Thanks.")
                        } else {
                            console.log("Cannot contain spaces.")
                        } 
                    }
                    else {
                        console.log("Password too short! Must be 6+ characters")
                    }
                </code></pre>

        <h3>truthy & falsy values</h3>
        <p>
            Falsy values:
            <br>false
            <br>0
            <br>"" <span class="red">empty string</span>
            <br>null
            <br>undefined
            <br>NaN
            <br>Everything else is truthy!
        </p>
        <pre><code>
                    const userInput = prompt("Enter something")
                    if (userInput) {
                        console.log("TRUTHY!")
                    } else {
                        console.log("FALSY!")
                    }
                </code></pre>
        Result: if user don't write anything and hit Enter, result will be "FALSY!".

        <h3>Logical operator AND</h3>
        <p>Logical operators are operators that can combine two or more pieces of logic together.
        </p>
        AND is written:
        <br>&&


        <pre><code>
                    1 <= 4 && 'a' === 'a';   //true 
                    9>10 && 9>=9;     //false
                    'abc'.length === 3 && 1+1 === 4;    //false 
                </code></pre>
        Combining the previous example in one IF using &&:
        <pre><code>
                    const password = prompt("Enter your password");
                    if (password.length >= 6 && password.indexOf(' ') === -1) {
                        constant.log("Valid password!")
                    } else {
                        constant.log("Invalid password!")
                    }
                </code></pre>

        <h3>Logical operator OR</h3>
        <p>If one side is true, the entire thing is true. If all sides are falsy, then the entire thing is
            false.</p>
        OR is written:
        <br>||
        <br>1 !== 1 || 10 ===10; //true
        <br>10/2 === 5 || null //true
        <br>0 || undefined //false
        <pre><code>
                    0-5 FREE <span class="red">*</span>
                    5-10 CHILD $10
                    10-65 ADULT $20
                    65+ FREE <span class="red">*</span>

                    const age = 90;
                    if (age < 5 || age >= 65) {
                        console.log("FREE")
                    } else if (age < 10) {
                        console.log("$10")
                    } else if (age < 65) {
                        console.log("$20")
                    }
                </code></pre>
        <pre><code>
                    0-5 FREE <span class="red">*</span>
                    5-10 CHILD $10
                    10-65 ADULT $20
                    65+ FREE <span class="red">*</span>
                    Age cannot be  less than 0. <span class="red">*</span>

                    const age = prompt("Enter your age please.");
                    if (age >=0 && age < 5 || age >= 65) {
                        console.log("FREE")
                    } else if (age >= 5 && age < 10) {
                        console.log("$10")
                    } else if (age >= 10 && age < 65) {
                        console.log("$20")
                    } else {
                        console.log("INVALID AGE!")
                    }
                </code></pre>
        The && has priority over the ||, just as the * has priority over + or - on mathematics.

        <h3>Logical operator NOT</h3>
        <p>It turns the result of the operation into its logical opposite.</p>
        <pre><code>
                    !null     //true 
                    !(0===0)  //false 
                    !(3<=4)   //false 
                </code></pre>
        <pre><code>
                    let firstName = prompt("Enter your first name:");
                    if (!firstName) {
                        firstName = prompt("PLEASE enter the fucking name!");
                    }
                </code></pre>
        <h3>Switch</h3>
        <p>It simplifies your code when you have multiple 'else if's.</p>
        Converting a number from 1 to 7 into a week-day:
        <pre><code>
                    let day = prompt("Write a number from 1 to 7");
                    if (day === 1) {
                        console.log("Monday")
                    } else if (day === 2) {
                        console.log("Tuesday")
                    } else if (day === 3) {
                        console.log("Wednesday")
                    } else if (day === 4) {
                        console.log("Thursday")
                    } else if (day === 5) {
                        console.log("Friday")
                    } else if (day === 6) {
                        console.log("Saturday")
                    } else if (day === 7) {
                        console.log("Sunday")
                    } else {
                        console.log("I don't know that.")
                    }
                </code></pre>
        Using switch it turns to:
        <pre><code>
                    let day = prompt("Write a number from 1 to 7");
                    switch(day) {
                        case "1":
                            console.log("Monday");
                            break;
                        case "2":
                            console.log("Tuesday");
                            break;
                        case "3":
                            console.log("Wednesday");
                            break;
                        case "4":
                            console.log("Thursday");
                            break;
                        case "5":
                            console.log("Friday");
                            break;
                        case "6":
                            console.log("Saturday");
                            break;
                        case "7":
                            console.log("Sunday");
                            break;
                        default:
                            console.log("I don't know that!")
                    }
                </code></pre>

        <h2>Arrays</h2>
        Array is a data structure, a collection of data or variables.
        <br>let beatles = ['Paul', 'John', 'George', 'Ringo'];
        <br>Each element in the array has an index, just like letters inside strings.
        <br>beatles[2]; //'George'
        <br>beatles.length; //4
        <br>To modify arrays:
        <br>beatles[1] = 'Lennon';
        <br>beatles; // ['Paul', 'Lennon', 'George', 'Ringo']

        <h3>Array Methods</h3>
        <h4>push & pop</h4>
        <p>arrayName.push('new item') adds 'new item' to the end of the array.</p>
        <br>beatles.push('new member');
        <br>beatles; //['Paul', 'Lennon', 'George', 'Ringo', 'new member']
        <p>arrayName.pop() removes the last, most recently pushed item of the array.</p>
        <br>beatles.pop();
        <br>beatles; //['Paul', 'Lennon', 'George', 'Ringo']
        <h4>shift & unshift</h4>
        <p>arrayName.shift() removes the first item off the array.</p>
        beatles.shift();
        <br>beatles; // ['Lennon', 'George', 'Ringo']
        <p>arrayName.unshift('new item') adds 'new item' to the beginning of the array.</p>
        beatles.unshift('Yoko');
        <br>beatles; //['Yoko', 'Lennon', 'George', 'Ringo']
        <h4>concat</h4>
        <p>Merges two arrays.</p>
        let flowers = ['marygold','lavender'];
        <br>let teas = ['lemmongrass','mint'];
        <br>flowers.concat(teas);
        <br>//['marygold','lavender','lemmongrass','mint'] <span class="red">it doesn't modify the original
            variables, it just returns a result of a list of the items of the two arrays together.</span>
        <h4>includes</h4>
        <p>arrayName.includes('cat') checks if the array includes the item 'cat' or not. Returns boolean.</p>
        flowers.includes('marygold'); //true
        <h4>indexOf</h4>
        <p>arrayName.indexOf('marygold') returns the index of a given item.</p>
        flowers.indexOf('marygold'); //0
        <br>If the item is not found in the array, it will return -1.
        <h4>reverse</h4>
        <p>arrayName.reverse() will reverse the order of items in the array.</p>
        flowers.reverse();
        <br>flowers; //['lavender','marygold']
        <br>It is a destructive method, i.e. it modifies the original array.
        <h4>slice</h4>
        <p>arrayName.slice(3) will return items from index 3 until the end, including item 3.</p>
        <p>arrayName.slice(3,5) will return items from index 3 until index 5, including item 3 and NOT including
            item 5.</p>
        <p>arrayName.slice(-2) will return last 2 items.</p>
        <p>slice is a non-destructive method.</p>
        <h4>splice</h4>
        <p>arrayName.splice(1,0,'rose') will begin at index 1, cut-out 0 items, and add 'rose'.</p>
        splice is a distructive method.
        <h4>sort (1/2)</h4>
        <p>arrayName.sort() will organize items according to function wrapped between parenthesis.</p>
        <h3>Reference types (arrays) and Equality tests</h3>
        let array1 = [1,2,3];
        <br>let array2 = [1,2,3];
        <br>array1 === array2 //false
        <br><br>
        let array1 = [1,2,3];
        <br>let array2 = array1;
        <br>array1 === array2 //true
        <p>What is being compared is the reference of the arrays, not the items inside of it.</p>
        <h3>Nested arrays</h3>
        let gameBoard = [["X", "O", "X"], ["O", null, "X"], ["O","O", "X"]];
        <br>To return the second item in second row:
        <br>gameBoard[1][1]; //null



        <h2>Objects</h2>
        <p>Just like arrays, objects are data structures. Inside objects, order doesn't matter. An object is
            formed by several properties. A property is a key-value pair, formed by a key and a value.</p>
        <pre><code>
                const person = {firstName: 'Pabblo', lastName: 'Vittar'};
                const myKitchen = {
                    isNice: true,
                    colors: ['green','white'],
                    sizeM2: 22
                }
                person["lastName"]  //'Vittar'
                person.lastName     //'Vittar'
                person["last"+"Name"]   //'Vittar' <span class="red">using [], you can put an operation or a variable inside the []</span>
                </code></pre>
        Modifying values and adding properties:
        <pre><code>
                myKitchen.size = 23;
                myKitchen.isClean = true;
                myKitchen;    //{isNice: true, colors: ['green','white'], sizeM2: 23, isClean: true}
                </code></pre>
        Nesting arrays and objects:
        <pre><code>
                    const shoppingCart = [
                    {
                        product: 'Jenga Classic',
                        price: 6.88,
                        quantity: 1,
                    },
                    {
                        product: 'Echo Dot',
                        price: 29.99,
                        quantity: 3
                    },
                    {
                        product: 'Fire Stick',
                        price: 39.99,
                        quantity: 2
                    }
                    ]
                </code></pre>

        <pre><code>
                    const comments = [
                        {username: 'Tammy', text: 'lolololol', votes: 9},
                        {username: 'Fishboy', text: 'glub glub', votes: 737637}
                    ]
                    comments[1];   //{username: 'Tammy', text: 'lolololol', votes: 9}
                    comments[1].text   //"glub glub"
                </code></pre>

        <h2>Loops</h2>
        Loops are used to repeat lines of code over and over again, until the condition inside of it returns
        false.
        <h3>For loops</h3>
        For loops syntax:
        <pre><code>
                    for (
                        [initialExpression];
                        [condition];
                        [incrementExpression]
                    )
                </code></pre>
        For example. To console.log a list from 1 to 10:
        <pre><code>
                    for (let i = 1; i <= 10; i++) {
                        console.log(i);
                    }
                </code></pre>
        Another example. To print "Da ba dee da ba daa" 6 times, no more no less than 6 times:
        <pre><code>
                    for (let i = 1; i <= 6; i++ ) {
                        console.log("Da ba dee da ba daa")
                    }
                </code></pre>
        Example 3. Print out all the even numbers between 0 and 20.
        <pre><code>
                    for (let i = 0; i <= 20; i += 2) {
                        console.log(i)
                    }
                </code></pre>
        Example 4. Count down all the multiples of 10, from 100 to 0.
        <pre><code>
                    for (let i = 100; i >= 0; i -= 10) {
                        console.log(i)
                    }
                </code></pre>
        Take care with infinite loops! They can cause problem, like force-quit the browser. For example:
        <pre><code>
                    for (let i = 20; i >= 0; i++) {
                        console.log(i)
                    }
                </code></pre>

        <h4>Looping over arrays</h4>
        For example. To list every item from this array:
        <pre><code>
                    const animals = ['lions','tigers','bears'];
                    for (let i = 0; i < animals.length; i++) {
                        console.log(i, animals[i]);
                    }
                    //0 'lions'
                    //1 'tigers'
                    //2 'bears'
                </code></pre>
        Example 2. To list items in reverse order:
        <pre><code>
                    const animals = ['lions','tigers','bears'];
                    for (let i = animals.length - 1; i >= 0; i--) {
                        console.log(i, animals[i]);
                    }
                    //2 'bears'
                    //1 'tigers'
                    //0 'lions'
                </code></pre>
        Example 3. Iterating (=listing, repeating) arrays items in uppercase.
        <pre><code>
                    const people = ["Scooby", "Velma", "Daphne", "Shaggy", "Fred"];
                    for (let i = 0; i < people.length; i++) {
                        console.log(people[i].toUpperCase());
                    }
                </code></pre>
        Example 4. Iterating an array and creating another array based on the iteration:
        <pre><code>
            const jonas = [
            'Jonas',
            'Schmedtmann',
            2022-1991,
            'teacher',
            ['Micheal', 'Peter', 'Steven'],
            true
            ];
            const types = [];
            for (let i=0; i<jonas.length; i++) {
                types[i] = typeof jonas[i];
                <span class="red">this will create an array formed by the types of the elements in the jonas array</span>
            }
            console.log(types);
            //['string', 'string', 'number', 'string', 'object', 'boolean']

        </code></pre>
        This example can also have this other (more simple) solution:
        <pre><code>
            const jonas = [
            'Jonas',
            'Schmedtmann',
            2022-1991,
            'teacher',
            ['Micheal', 'Peter', 'Steven'],
            true
            ];
            const types = [];
            for (let i=0; i<jonas.length; i++) {
                types.push(typeof jonas[i]);
                <span class="red">this also will create an array formed by the types of the elements in the jonas array, but this time the push method is being used.</span>
            }
            console.log(types);
            //['string', 'string', 'number', 'string', 'object', 'boolean']
        </code></pre>
        Example 5. Picking an array of years and calculating a new array of ages.
        <pre><code>
            const years = [1991, 2007, 1983, 1984, 1990];
            const ages = [];
            for (let i=0; i&ltyears.length; i++) {
                ages.push(2022-years[i])
            }
        </code></pre>
        Example 6. Iterating array backwards.
        <pre><code>
            const jonas = [
    'Jonas',
    'Schmedtmann',
    2022 - 1991,
    'teacher',
    ['Micheal', 'Peter', 'Steven'],
    true
];
const jonasBW = [];
for (let i = jonas.length - 1; i >= 0; i--) {
    jonasBW.push(jonas[i]);
}
        </code></pre>


        <h4>Nesting loops</h4>
        Used to list every item in every nested array inside of an array.
        <pre><code>
                    const seatingChart = [
                        ['Kristen', 'Erik', 'Namita'],
                        ['Geoffrey', 'Juanita', 'Antonio', 'Kevin'],
                        ['Yuma', 'Sakura', 'Jack', 'Erika']
                    ]
                    for (let i = 0; i < seatingChart.length; i++) {
                        const row = seatingChart[i];
                        console.log(`ROW #${i + 1}`)
                        for (let j = 0; j < row.length; j++) {
                            console.log(row[j])
                        }
                    }
                    //ROW #1
                    //Kristen
                    //Erik
                    //Namita
                    //ROW #2
                    //Geoffrey
                    //Juanita
                    //Antonio
                    //Kevin
                    //ROW #3
                    //Yuma
                    //Sakura
                    //Jack
                    //Erika
                </code></pre>
        Example 2. Creating an array with multiple arrays inside of it.
        <pre><code>
            const workout = [];
for (let exercise = 1; exercise < 4; exercise++) {
    for (let repetition = 1; repetition < 6; repetition++) {
        workout.push([`Exercise ${exercise}: repetition ${repetition}`]);
    }
}
workout;
//[['Exercise 1: repetition 1'], 
['Exercise 1: repetition 2'], 
['Exercise 1: repetition 3'], 
['Exercise 1: repetition 4'], 
['Exercise 1: repetition 5'], 
['Exercise 2: repetition 1'], 
['Exercise 2: repetition 2'], 
['Exercise 2: repetition 3'], 
['Exercise 2: repetition 4'], 
['Exercise 2: repetition 5'], 
['Exercise 3: repetition 1'], 
['Exercise 3: repetition 2'], 
['Exercise 3: repetition 3'], 
['Exercise 3: repetition 4'], 
['Exercise 3: repetition 5']]
        </code></pre>

        <h3>While loops</h3>
        Can do the same things as for loops, but are usually used when something needs to be repeated over and
        over again and when it is not known when it's gonna end.
        <pre><code>
                    const SECRET = "BabyHippo";
                    let guess = prompt("Enter the secret code.....");
                    while (guess !== SECRET) {
                        guess = prompt("Enter the secret code.....");
                    }
                    console.log("CONGRATS! YOU GOT IT!")
                </code></pre>
        Example 2. Translating a for loop into a while loop:
        <pre><code>
            <span class="red">for loop:</span>
            for (let rep=1; rep<=3; rep++) {
                console.log(`Lifting weight repetition ${rep}`);
            }
            <span class="red">while loop:</span>
            let rep = 1;
            while (rep<=3) {
                console.log(`Lifting weight repetition ${rep}`);
                rep++;
            }
        </code></pre>

        Example 3. Rolling a die until the result is 6.
        <pre><code>
            let dice = Math.trunc(Math.random() * 6) + 1 <span class="red">Math.trunc is conceptually different from Math.floor, but they do the same thing. Math.trunc erases all decimals, Math.floor rounds towards closest integer number.</span>
            while (dice !== 6) {
                console.log(`You rolled a ${dice}`);
                if (dice===6){
                    console.log("You got a 6!");
                }
                dice = Math.trunc(Math.random() * 6) + 1;
            }
        </code></pre>

        <h4>The break keyword</h4>
        <pre><code>
                    let input = prompt("Hey, say something!")
                    while (true) {
                        input = prompt(input);
                        if (input.toLowerCase() === "stop copying me") {
                            break;
                        }
                    }
                    alert("OK YOU WIN!")
                </code></pre>
        The "opposite" of the break keyword is the continue keyword. It tells the code to skip that one iteration when
        some condition is found.
        <pre><code>
                    const jonas = [
                    'Jonas',
                    'Schmedtmann',
                    2022-1991,
                    'teacher',
                    ['Michael','Peter','Steven']
                    ]
                    for (let i=0; i>jonas.length; i++) {
                        if(typeof jonas[i]!=='string') continue; <span class="red">if the content of that given item is not a string, it will be skipped.</span>
                        console.log(jonas[i], typeof jonas[i]);
                    }
                    
                </code></pre>

        <h4>Writing a Guessing Game</h4>
        <pre><code>
                let maximum = parseInt(prompt("Enter the maximum number!"));
                while (!maximum) {
                    <span class="red">while maximum is a falsy (not a number, 0, etc.)</span>
                    maximum = parseInt(prompt("Enter a valid number!"));
                }

                const targetNum = Math.floor(Math.random() * maximum) + 1;

                let guess = parseInt(prompt("Enter your first guess!"));
                let attempts = 1;

                while (parseInt(guess) !== targetNum) {
                    if (guess === 'q' || guess === 'Q') break;
                    attempts++;
                    if (guess > targetNum) {
                        guess = prompt("Too high! Enter a new guess:");
                    } else {
                        guess = prompt("Too low! Enter a new guess:");
                    }
                }

                if (guess === 'q' || guess === 'Q') {
                    alert("OK, you quit.")
                } else {
                    alert(`Congrats! It took you ${attempts} guesses.`)
                }
                </code></pre>

        <h3>For...of loops</h3>
        <p>These are used to iterate items of an iterable (strings, arrays etc). It is also possible to
            use for loops for this purpose, but for...of loops are a new JS feature that does this in a simpler
            way.</p>
        <pre><code>
                    const people = ["Scooby", "Velma", "Daphne", "Shaggy", "Fred"];
                    for (let i = 0; i < people.length; i++) {
                        console.log(people[i].toUpperCase());
                    }
                    <span class="red">This is ok, but can be done in a cleaner way:</span>
                    const people = ["Scooby", "Velma", "Daphne", "Shaggy", "Fred"];
                    for (let person of people) {
                        console.log(person)
                    }
                </code></pre>
        Another example:
        <pre><code>
                    const seatingChart = [
                        ['Kristen', 'Erik', 'Namita'],
                        ['Geoffrey', 'Juanita', 'Antonio', 'Kevin'],
                        ['Yuma', 'Sakura', 'Jack', 'Erika']
                    ]
                    for (let i = 0; i < seatingChart.length; i++) {
                        const row = seatingChart[i];
                        for (let j = 0; j < row.length; j++) {
                            console.log(row[j])
                        }
                    }
                    <span class="red">This is ok, but using for...of loop it is easier:</span>
                    const seatingChart = [
                    ['Kristen', 'Erik', 'Namita'],
                    ['Geoffrey', 'Juanita', 'Antonio', 'Kevin'],
                    ['Yuma', 'Sakura', 'Jack', 'Erika']
                ]
                    for (let line of seatingChart) {
                        for (let person of line) {
                            console.log(person)
                        }
                    }
                </code></pre>

        <h4>Iterating over Objects</h4>
        <p>Objects are not iterable because its items are unordered and don't have an index. So you can't use
            for...of with them. But there are a couple of ways to iterate over objects.</p>
        For...in loop:
        <pre><code>
                        const testScores = {
                            keenan: 80,
                            damon: 67,
                            kim: 89,
                            shawn: 91
                        }
                        for (let person in testScores) {
                            console.log(person)
                        }
                        //keenan
                        //damon
                        //kim
                        //shawn
                        <span class="red">(just returns the keys, not the values)</span>
                    </code></pre>

        For...in + values
        <pre><code>
                        const testScores = {
                            keenan: 80,
                            damon: 67,
                            kim: 89,
                            shawn: 91
                        }
                        for (let person in testScores) {
                            console.log(`${person} scored ${testScores[person]})
                        }
                        //keenan scored 80
                        //damon scored 67
                        //kim scored 89
                        //shawn scored 91
                    </code></pre>

        Object.keys() method
        <pre><code>
                        const testScores = {
                            keenan: 80,
                            damon: 67,
                            kim: 89,
                            shawn: 91
                        }
                        console.log(Object.keys(testScores));
                        //["keenan", "damon", "kim", "shawn"]
                    </code></pre>

        Object.values method
        <pre><code>
                        const testScores = {
                            keenan: 80,
                            damon: 67,
                            kim: 89,
                            shawn: 91
                        }
                        console.log(Object.values(testScores));
                        //[80, 67, 89, 91]
                    </code></pre>

        Object.entries method
        <pre><code>
                        const testScores = {
                            keenan: 80,
                            damon: 67,
                            kim: 89,
                            shawn: 91
                        }
                        console.log(Object.entries(testScores));
                        //[["keenan", 80], ["damon", 67], ["kim", 89], ["shawn", 91]]
                    </code></pre>

        Example: to sum up all of the scores and get an avarage of them.
        <pre><code>
                        const testScores = {
                            keenan: 80,
                            damon: 67,
                            kim: 89,
                            shawn: 91
                        }
                        let total = 0;
                        let numberOfStudents = Object.values(testScores).length
                        for (let eachScore of Object.values(testScores)) {
                            total += eachScore;
                        }
                        console.log(total / numberOfStudents)
                    </code></pre>

        <h3>Functions</h3>
        <p>Functions allow us to write reusable, modular code. With them, we define a "chunk" of code that we
            can execute at a later point.</p>
        <p>First, we have to define and "register" the function. Then we have to run it anywhere in our code.
        </p>
        <p>Defining a function:</p>
        <pre><code>
                        function funcName() {
                            //do something
                        }
                    </code></pre>
        Defining and running a function 2 times:
        <pre><code>
                        function singSong(){
                            console.log(DO);
                            console.log(RE);
                            console.log(MI);
                        }
                        singSong();
                        singSong();
                        //DO
                        //RE
                        //MI
                        //DO
                        //RE
                        //MI
                    </code></pre>

        <h4>Functions with parameter/arguments</h4>
        <p>Arguments are values which we put inside the parenthesis of a function, providing the function with a
            certain input.</p>
        <p>Parameter are the value we set inside parenthesis when a function is defined. So, don't confuse
            paramenter with argument!</p>
        <pre><code>
                        function greet(firstName) { <span class="red">firstName is a parameter</span>
                            console.log(`Hi, ${firstName}!`);
                        }
                        greet('Elvis'); <span class="red">Elvis is an argument</span>
                        //Hi, Elvis!
                 </code></pre>
        <pre><code>
                    function rant(message){
                        console.log(message.toUpperCase());
                        console.log(message.toUpperCase());
                    }
                    rant('I hate beets!');
                    //I HATE BEETS!
                    //I HATE BEETS!
                 </code></pre>

        <h4>Functions with more than one parameter</h4>
        <p>The order of the arguments matters, because the first will correspond to the first parameter, and so
            on.</p>
        <pre><code>
                 function greet(firstName, lastName) {
                     console.log(`Hi, ${firstName} ${lastName[0].});
                 }
                 greet('Elvis','Presley');
                 //Hi, Elvis P.
                </code></pre>
        Example 2: repeat a message X times in a same string:
        <pre><code>
                    function repeat(message, numTimes){
                        let result = '';
                        for (let i = 0; i < numTimes; i++) {
                            result += message;
                        }
                        console.log(result);
                    }
                    repeat(HELLO,5);
                    //HELLOHELLOHELLOHELLOHELLO
                </code></pre>
        In some dice games like Craps, a roll of two 1's is called 'Snake Eyes'. It is generally not a good
        roll. Please write a function called isSnakeEyes, which accepts two numbers as inputs, representing two
        dice. If the two numbers are both 1's, please print 'Snake Eyes!', otherwise print 'Not Snake Eyes!'.
        <pre><code>
                    function isSnakeEyes(num1,num2){
                        if (num1===1 && num2===1){
                            console.log("Snake Eyes!")
                        } else {
                            console.log("Not Snake Eyes!")
                        }
                    }
                    isSnakeEyes(1,2);
                    //Not Snake Eyes!
                    isSnakeEyes(3,6);
                    //Not Snake Eyes!
                    isSnakeEyes(1,1);
                    //Snake Eyes!
                </code></pre>

        <h4>The return keyword</h4>
        <p></p>
        <pre><code>
                    function(x,y){
                        console.log(x+y);
                    }
                    add(9,4);
                    //13
                    let total = add(9,4);
                    total;
                    //undefined  <span class="red">this is because if the return keyword has not been used, the function is not a capturable value.</span>
                </code></pre>
        <p>The return keyword is used to be able to capture the value of a function in a variable.</p>
        <pre><code>
                    function(x,y){
                        return x + y;
                    }
                    add(9,4);
                    //13
                    let total = add(9,4);
                    total;
                    //13
                </code></pre>
        <p>The return keyword interrupts the function where it appears, so that the following lines of the
            function will never be executed.</p>
        <pre><code>
                    function add(x,y){
                        if (typeof x !== 'number' || typeof y !== 'number') {
                            return false;
                        }
                        return x + y;
                    }
                    add(2,3);
                    //5
                    add(2,'a');
                    //false
                    add(5,add(6,7));
                    //18
                </code></pre>

        <h4>Exercises (functions)</h4>
        <p>1. Define a function called rant which accepts a string argument called massage. The function should print
            out an uppercased version of message 3 times (with 3 separate calls to console.log).</p>
        <pre><code>
                    function rant(message){
                        console.log(message.toUpperCase());
                        console.log(message.toUpperCase());
                        console.log(message.toUpperCase());
                    }
                    rant("I hate beets");
                    //I HATE BEETS
                    //I HATE BEETS
                    //I HATE BEETS
                </code></pre>

        <p>2. Write a simple function called multiply which accepts two numerical arguments and return their product
            (multiply them together). Make sure to return the value instead of printing it.</p>
        <pre><code>
                    function multiply(num1,num2){
                        return num1 * num2;
                    }
                    multiply(3,4);
                    //12
        </code></pre>
        <p>3. I often struggle to know whether I should wear shorts or pants on a given day. Please help me decide by
            writing me a function called isShortsWeather. It should accept a single number argument which we will call
            temperature. If temperature is greater than 75, return true. Otherwise, return false. </p>
        <pre><code>
            function isShortsWeather(temperature){
                if (temperature >= 75) {
                    return true;
                } else {
                    return false;
                }
            }
            isShortsWeather(60);
            //false
            isShortsWeather(78);
            //true
        </code></pre>
        <p>4. Write a function called lastElement which accepts a single array argument. The function should return the
            last element of the array (without removing the element). If the array is empty, the function should return
            null.</p>
        <pre><code>
            function lastElement(myArray) {
                if (myArray.length === 0) {
                    return null;
                }
                return myArray[myArray.length-1];
            }
            lastElement([3,5,7]);
            //7
            lastElement([]);
            //null 
        </code></pre>
        <p>5. Define a function called capitalize that accepts a string argument and returns a new string with the first
            letter capitalized(but the rest of the string unchanged). For example: capitalize('eggplant') //"Eggplant"
        </p>
        Hints:
        <br>Remember that strings are immutable, meaning that you cannot simply change the first letter in the original
        string. You will need to make a new string that you return.
        <br>Single out the first letter and capitalize it. (use a string method!)
        <br>Add the first letter to the rest of the original string, sliced to omit the first letter. (use a string
        method!)
        <br>For example: 'eggplant' becomes 'E'+'ggplant'
        <pre><code>
            function capitalize(string) {
                return string[0].toUpperCase() + string.slice(1)
            }
            capitalize('wonderful');
            //Wonderful
        </code></pre>
        <p>6. Write a function called sumArray which accepts a single argument: an array of numbers. It should return
            the sum of all the numbers in the array. Ex: sumArray([1,2,3]); //6</p>
        Hints:
        <br>You'll need a variable to keep track of the total. It should start out as 0.
        <br>Loop over the array and for each element, add it to the total variable.
        <br>After you have added every number to total, return total.
        <pre><code>
            function sumArray(array) {
                let sum = 0;
                for (let num of array) {
                    sum += num;
                }
                return sum;
            }
            sumArray([2,3,4]);
            //9
        </code></pre>
        <p>7. Write a function called returnDay. This function takes in one parameter (a number from 1-7) and returns
            the day of the week (1 for Monday, 2 for Tuesday,...) If the number is less than 1 or greater than 7, the
            function should return null. </p>
        Hint: store the days of the week in an array, or use an object with numerical keys. When the function is called,
        plug the number into the array/object you've created to retrieve the corresponding day name and then return that
        value.
        <br>Using if, else if:
        <pre><code>
            function returnDay(num) {
                if (num < 1 || num > 7) {
                    return null;
                } else if (num===1){
                    return "Monday";
                } else if (num===2){
                    return "Tuesday";
                } else if (num===3){
                    return "Wednesday";
                } else if (num===4){
                    return "Thursday";
                } else if (num===5){
                    return "Friday";
                } else if (num===6){
                    return "Saturday";
                } else if (num===7){
                    return "Sunday";
                }
            }
        </code></pre>
        Using array:
        <pre><code>
            function returnDay(num) {
                if (num < 1 || num > 7) {
                    return null;
                } else {
                    let days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                    return days[num-1];
                }
            }
        </code></pre>
        Using object:
        <pre><code>
            function returnDay(num) {
                if (num < 1 || num > 7) {
                    return null;
                } else {
                    let days = {1:'Monday', 2:'Tuesday', 3:'Wednesday', 4:'Thursday', 5:'Friday', 6:'Saturday', 7:'Sunday'};
                    return days[num];
                }
            }
        </code></pre>

        <h4>Scope</h4>
        <p>A variable let or const declared inside of a function{} or inside of a conditional{} cannot be expressed
            outside of this {}.</p>
        <pre><code>
            let animal = "Octopus";
            function observe() {
                let animal = "Squid";
                console.log(animal);
            }
            observe();
            //"Squid"
            animal;
            //"Octopus"
        
        </code></pre>
        <pre><code>
            const creature = "Dragon";
            function captureCreature(){
                const creature = "Fish";
                console.log(creature);
            }
            captureCreature();
            //"Fish"
            creature;
            //"Dragon"
        </code></pre>
        <pre><code>
            let deadlyAnimal = "Octopus";
            function handleAnimal(){
                let deadlyAnimal = "Scorpion";
                console.log(deadlyAnimal);
            }
            handleAnimal();
            //"Scorpion"
            console.log(deadlyAnimal);
            //"Octopus"
        </code></pre>
        <p>If there is a function nested inside of a function, the variables defined inside of the parent function is
            also valid inside of the nested function.</p>
        <pre><code>
            function outer(){
                let hero = "Black Panther";
                function inner(){
                    let cryForHelp = `${hero}, please save me!`;
                    console.log(cryForHelp);
                }
                inner();
            }
            outer();
            //Black Panther, please save me!

        </code></pre>
        <p>PS: but variables declared using the var key won`t obey any scope, and will be valid all along the js file
            once they've been declared.</p>

        <h4>Function expressions</h4>
        It is another way of defining a function, through assigning it to a variable.
        <pre><code>
            const square = function(num){
                return num*num;
            }
            square(7);
            //49
        </code></pre>

        <h4>Higher order functions</h4>
        <p>Using a function as an argument to an other function OR returning a function from a function. The "secondary"
            function that is called or returned is called Callback Function.</p>
        <p>Higher order functions add a level of abstraction into the code.</p>
        For example, creating a function to run twice another
        function:
        <pre><code>
            function callTwice(func){
                func();
                func();
            }
            function rollDie(){
                const roll = Math.floor(Math.random() * 6) + 1;
                console.log(roll);
            }
            callTwice(rollDie);
            //4
            //3
            <span class="red">In this example, callTwice is the Higher Order Function, and rollDie is the Callback Function.</span>
        </code></pre>
        For example, creating a function to run ten times another function:
        <pre><code>
            function callTenTimes(funct){
                for (let i=0; i&lt10; i++) {
                    funct();
                }
            }
            
            function rollDie(){
                const roll = Math.floor(Math.random() * 6) + 1;
                console.log(roll);
            }

            callTenTimes(rollDie);
        </code></pre>
        Another example (Jonas):
        <pre><code>
            const oneWord = function (str) {
                return str.replace(/ /g, '').toLowerCase();
            }; <span class="red">this function deletes all empty spaces on the string and converts it to lower case.</span>

            const upperFirstWord = function (str) {
                const [first, ...others] = str.split(' ');
                return [first.toUpperCase(), ...others].join(' ');
            }; <span class="red">this function converts the first word to uppercase. in order to do that, we used array Deconstructing, Rest and Spread.</span>

            const transformer = function(str, fn) {
                console.log(`Original string: ${str}`);
                console.log(`Transformed string: ${fn(str)}`);
                console.log(`Transformed by: ${fn.name}`);
            }; <span class="red">this Higher Order Function takes one function and a string, and calls the function with the string as its argument. The name of the function that was called is retrieved by the property .name;</span>

            transformer('JavaScript is the best!', oneWord);
            //Original string: JavaScript is the best!
            //Transformed string: javascriptisthebest!
            //Transformed by: oneWord

            transformer('JavaScript is the best!', upperFirstWord);
            //Original string: JavaScript is the best!
            //Transformed string: JAVASCRIPT is the best!
            //Transformed by: upperFirstWord

        </code></pre>



        <h4>Return function</h4>
        <p>Returning a function as a value from within a function. This feature allows us to make some sort of "function
            factories", that is, a function that creates other functions.</p>
        <pre><code>
            function makeBetweenFunc(min, max){
                return function(num){
                    num >= min && num <= max;
                }
            } <span class="red">This is a factory function! It helps creating other functions.</span>
            const isChild = makeBetweenFunc(0,18); <span class="red">Now I'm creating a function using the factory function!</span>
            isChild(40);
            //false
            isChild(7);
            //true 
            const isAdult = makeBetweenFunc(19,64); <span class="red">Now I'm creating another one!</span>
            const isSenior = makeBetweenFunc(65,120); <span class="red">And another!</span>
            isAdult(17);
            //false 
            isSenior(66);
            //true 
            
        </code></pre>
        <p>Another example (Jonas):</p>
        <pre><code>
            const greet = function (greeting) {
                return function (name) {
                    console.log(`${greeting}, ${name}`);
                };
            };

            const greeterHey = greet('Hey');

            greeterHey('Jonas');
            //Hey, Jonas
            greeterHey('Steven');
            //Hey, Steven
            
            greet('Hello')('Jonas');
            //Hello, Jonas

            <span class="red">Using arrow functions:</span>
            const greet = greeting => name => console.log(`${greeting}, ${name}`);
        </code></pre>

        <h4>Defining Methods</h4>
        <p>We can add functions as properties on objects. We call them methods. </p>
        <p>Every method is a function (for ex., "hello".toUpperCase), but not all function is a method.</p>
        <pre><code>
            const myMath = {
                PI: 3.14159,
                square: function (num) {
                    return num * num;
                },
                cube: function (num) {
                    return num ** 3;
                }
            }
            myMath.PI;
            //3.14159
            myMath.square(3);
            //9
            myMath.cube(2);
            //8
        </code></pre>
        We do this so often that there's a new shorthand for adding methods:
        <pre><code>
            const myMath = {
                PI: 3.14159,
                square(num) {
                    return num * num;
                },
                cube(num) {
                    return num ** 3;
                }
            }
        </code></pre>

        <h4>The keyword "this"</h4>
        <p>The this keyword/variable is a special variable that is created for every execution context (every function).
            It takes the value of (points to) the "owner" of the function in which it is used.</p>
        <p>"this" is NOT static. It depends on HOW the function is called, and its value is only assigned when the
            function <b>is actually called</b>.</p>
        <h5>this inside of Methods</h5>
        <pre><code>
        const jonas = {
            name: 'Jonas',
            year: 1989,
            calcAge: function() {
                return 2022 - this.year;
            }
        } <span class="red">here, this' value is jonas.</span>
        jonas.calcAge(); 
        //33

        </code></pre>

        <h5>this in the global scope</h5>
        Refers directly to the window object.

        <h5>this in simple function call</h5>
        In this case, in strict mode, this' value will be undefined.
        If strict mode is not activated (sloppy mode), this' value will point to the window object.

        <h5>this in Arrow functions</h5>
        this' value will point to the parent function. It is called "lexical this", because it retains the value of the
        outer lexical scope. That is, arrow functions do not get their own this keyword, as they don't have it.

        <h5>this in EventListeners</h5>
        this' value will point to the DOM element that the handler is attached to.

        <!-- <h5>new, call, apply, bind Methods</h5> -->
        <h5>call, apply, bind methods</h5>
        <p>These methods are used to force the this keyword to refer to a specific object.</p>
        <pre><code>
            const lufthansa = {
                airline: 'Lufthansa',
                iataCode: 'LH',
                bookings: [],
                book(flightNum, name) {
                    console.log(`${name} booked a seat on ${this.airline} flight ${this.iataCode}${flightNum}`);
                    this.bookings.push({ flight: `${this.iataCode}${flightNum}`, name });
                }
            };

            lufthansa.book(239, 'Jonas Schmedtmann'); <span class="red">works fine.</span>

            const eurowings = {
                airline: 'Eurowings',
                iataCode: 'EW',
                bookings: []
            };

            const book = lufthansa.book;

            book(23, Sarah Williams); <span class="red">doesn't work, because the this keyword will refer to the window object!</span>

            book.call(eurowings, 23, 'Sarah Williams'); <span class="red">the CALL method receives as arguments: 1st the object target by the this keyword, 2nd the function's other arguments</span>

            book.call(lufthansa, 239, 'Mary Cooper');
        </code></pre>
        <p>The apply method works the same way as the call method, but receives an array of arguments as the function's
            arguments.</p>
        <pre><code>
            const flightData = [583, 'George Cooper'];
            book.apply(eurowings, flightData);

            <span class="red">nowadays, the apply method isn't very used. Instead, we use spread operator and call method:</span>
            book.call(eurowings, ...flightData);
        </code></pre>
        <p>The bind method works the same way as the call method, but it generates a new function where the this keyword
            is set on stone.</p>
        <pre><code>
            const bookEW = book.bind(eurowings);
            const bookLH = book.bind(lufthansa);

            bookEW(23, 'Steven Williams');
            <span class="red">only need to write the arguments of the function. In the example, the function book takes as parameters (flightNum, name).</span>

            const bookEW334 = book.bind(eurowings, 334); <span class="red">this function has the this keyword set to the eurowings object, and the first argument is set to 334. This is called Partial Application.</span>
            bookEW334('Mary Dritschel');

            <span class="red">Using bind method with Event Listener:</span>
            const lufthansa = {
                airline: 'Lufthansa',
                iataCode: 'LH',
                bookings: [],
                book(flightNum, name) {
                    console.log(`${name} booked a seat on ${this.airline} flight ${this.iataCode}${flightNum}`);
                    this.bookings.push({ flight: `${this.iataCode}${flightNum}`, name });
                },
                planes: 300,
                buyPlane() {
                    this.planes++
                }
            };
            
            document.querySelector(#buttonX).addEventListener('click', lufthansa.buyPlane.bind(lufthansa));
            <span class="red">If there wasn't a bind method, the this keyword in the function buyPlane would be set to be the #buttonX element!</span>

            <span class="red">Using bind Method and Partial Application to create new functions from a function:</span>
            const addTax = (rate, value) => value + value * rate;

            const addVAT = addTax.bind(null, 0.23);
            <span class="red">This function has no this keyword, so we write null in the first place. </span>
            <span class="red">This is equal to: addVAT = value => value + value * 0.23 </span>
            <span class="red">This is also equal to (using high order function):</span>
            const addTax2 = function (rate){
                return function (value){
                    return value + value*rate;
                };
            };
            const addVAT2 = addTax2(0.23)
            console.log(addVAT2(100));
            //123
        </code></pre>



        <p>In methods inside of an object, use "this" to access other properties on the same object. This keyword is a
            complicated one, so just keep this simple concept.</p>
        <p>Example. Define an object called hen. It should have three properties:
            <br>name should be set to "Helen".
            <br>eggCount should be set to 0.
            <br>layAnEgg should be a method which increments the value of eggCount by 1 and returns the string "EGG".
        </p>
        <pre><code>
            const hen = {
                name: "Helen",
                eggCount: 0,
                layAnEgg(){
                    this.eggCount++;
                    return "EGG";
                }
            }
            hen.name;
            //"Helen"
            hen.eggCount;
            //0
            hen.layAnEgg();
            //"EGG"
            hen.layAnEgg();
            //"EGG"
            hen.eggCount;
            //2

        </code></pre>
        Another example:
        <pre><code>
            const jonas = {
                firstName: 'Jonas',
                lastName: 'Schmedtmann',
                birthYear: 1991,
                job: 'teacher',
                friends: ['Micheal', 'Peter', 'Steven'],
                hasDriversLicense: true,
                calcAge: function() {
                    return 2022 - this.birthYear;
                }
            }
            console.log(jonas.calcAge());
            //31
        </code></pre>
        Writing a summary of Jonas' characteristics as a method inside the object:
        <pre><code>
            const jonas = {
                firstName: 'Jonas',
                lastName: 'Schmedtmann',
                birthYear: 1991,
                job: 'teacher',
                friends: ['Micheal', 'Peter', 'Steven'],
                hasDriversLicense: true,
                driversLicense: function () {
                    if (this.hasDriversLicense) {
                        return 'a';
                    } else {
                        return 'no';
                    }
                },
                calcAge: function () {
                    return 2022 - this.birthYear;
                },
                getSummary: function () {
                    return `${this.firstName} is a ${this.calcAge()}-years old ${this.job}, and he has ${this.hasDriversLicense ? 'a' : 'no'} driver's license.`
                }
            }
            console.log(jonas.getSummary());
            <span class="red">Note that, inside the method getSummary, there is a ternary operator to decide whether he has a Drivers License or not.</span>
        </code></pre>

        <h4>The try / catch statements</h4>
        <p>These statements are used to prevent errors to crash the whole code.</p>
        <pre><code>
            hello.toUpperCase();
            // Uncaught reference error etc etc...  <span class="red">this stops the code from this point on</span>


            try {
                hello.toUpperCase();
            } catch {
                console.log("THERE IS AN ERROR")
            }
            //"THERE IS AN ERROR"  <span class="red">this just advices that there was an error, but the code is not stopped</span>

        </code></pre>
        <div class="alert-info p-3">
            <h5>Functions Review</h5>
            Function declaration: can be used before it's declared, because it is HOISTED, that is, it is read alongside
            the global (first) execution of code.
            <pre><code>
            function calcAge(birthYear){
                return 2022 - birthYear;
            }
        </code></pre>
            Function expression: essencially a function value stored in a variable. It is not HOISTED, that is, can't be
            used before it is declared. Behaves just as a const, let or var variable.
            <pre><code>
            const calcAge = function (birthYear) {
                return 2022 - birthYear;
            }
        </code></pre>
            Arrow function: great for quick one-line functions. Doesn't accept "this" keyword. Not HOISTED.

            <pre><code>
            const calcAge = birthYear => 2022 - birthYear;
        </code></pre>
            IIFE (Immediately Invoked Function Expression): are used to protect variables inside their scope. IIFE also
            can be very useful in Async.
            <pre><code>
            (function () {
                console.log('This will never run again');
            })();

            <span class="red">In arrow mode:</span>
            (() => console.log('This will never run again'));

            <span class="red">In order to protect variables from being invoked outside of a certain scope, we can also create a simple block {} and define the functions inside of this block.</span>
            {
                const isPrivate = 23;
                var isNotPrivate = 24;
                let privateToo = 25;
            }
        </code></pre>

        </div>

        <h3>Methods that accept function as parameters</h3>
        <h4>ForEach</h4>
        <p>Today it is not very used, because we already have for...of.</p>
        <pre><code>
            const numbers = [1,2,3,4];
            <span class="red">Using for...of:</span>
            <br>for (let el of numbers) {
                console.log(el);
            }
            <span class="red">Using forEach:</span>
            <br>numbers.forEach(function(el) {
                console.log(el);
            })
        </code></pre>

        <h4>.map method (the map method is different from the Map type of object!)</h4>
        <p>Calls the function for each element and creates a new array for them.</p>
        <p>This method is similar to forEach method, but it allows us to create a new array.</p>
        <pre><code>
            const numbers = [1,2,3,4];

            const doubles = numbers.map(function(num){
                return num * 2;
            })

            doubles;
            //[2,4,6,8]
        </code></pre>
        <pre><code>
            const movements = [200, 450, -400];
            const eurToUSD = 1.1;
            const movementsUSD = movements.map(function(mov) {
                return mov * eurToUSD;
            })
            console.log(movementsUSD);
            //[220, 495, -440]

            <span class="red">Using arrow function:</span>
            const movementsUSD = movements.map(mov => mov * eurToUSD);
        </code></pre>

        <h3>Arrow functions</h3>
        <p>Arrow functions are a more modern, more simple way of making a function expression. Arrow functions don't
            create 'arguments' property, as the other types of functions do. And their 'this' keyword points to the
            parent element.</p>
        <pre><code>
            const add = (x, y) => {
                return x + y;
            }
        </code></pre>
        <pre><code>
            const square = num => {
                return num * num;
            }
            <span class="red">in this case, there is only one parameter, so the parenthesis are optional.</span>
        </code></pre>
        <pre><code>
            const rollDie = () => {
                return Math.floor(Math.random() * 6 + 1);
            }
            <span class="red">in this case, there is no parameter, but the parenthesis are mandatory.</span>
        </code></pre>
        Implicit return:
        <pre><code>
            const isEven = num => {
                return num%2 === 0;
            }
            <span class="red">you can ommit the "return" keyword and add parenthesis instead of curly braces:</span>
            const isEven = num => {}
                num%2 === 0;
            )
            <span class="red">you can also ommit the parenthesis:</span>
            const isEven = num => num%2 === 0;
        </code></pre>
        Using arrow functions and implicit return in the functions inside maps:
        <pre><code>
            const numbers = [1,2,3,4];

            const doubles = numbers.map((num) => {
                return num * 2;
            })

            doubles;
            //[2,4,6,8]
        </code></pre>
        <pre><code>
            const numbers = [1,2,3,4];

            const doubles = numbers.map(num => (
                num * 2;
            ));

            doubles;
            //[2,4,6,8]
        </code></pre>
        <pre><code>
            const numbers = [1,2,3,4];

            const doubles = numbers.map(num => num * 2);

            doubles;
            //[2,4,6,8]
        </code></pre>

        <h4>setTimeout, setInterval</h4>
        <p>setTimeout sets up a callback (a function), and a delay (in ms miliseconds). The function will only be
            executed once the delay has finished.</p>
        <pre><code>
        setTimeout(() => {
            console.log("HELLO!!!");
        }, 3000)
        <span class="red">the message HELLO!!! will be printed 3s after the code is loaded.</span>
        </code></pre>
        <pre><code>
            setTimeout(
                (ing1, ing2) => console.log(`Here is your pizza with ${ing1} and ${ing2}`), 3000, 'olives', 'spinach'
            );
            <span class="red">3s later</span>//Here is your pizza with olives and spinach 
            <span class="red">setTimeout accepts as arguments: 1st: the callback function; 2nd: the time in ms; 3rd etc: the arguments for the callback function.</span>

            
            const pizzaFunction = function (...ingredients) {
                setTimeout(
                    (ing1, ing2) => console.log(`Here is your pizza with ${ing1} and ${ing2}`), 3000, ...ingredients
                );
            }
            
            pizzaFunction('chocolate', 'cheese');
        </code></pre>
        <p>The clearTimeout method cancels the Timeout.</p>
        <pre><code>
            const ingredients = ['olive', 'spinach'];
            const pizzaTimer = setTimeout((ing1, ing2) => console.log(`Here is your pizza with ${ing1} and ${ing2}`));

            if(ingredients.includes('spinach')) clearTimeout(pizzaTimer);
        </code></pre>

        <p>setInterval calls a given function every X miliseconds of time.</p>
        <pre><code>
            setInterval(() => {
                console.log(Math.random())
            }, 2000);
            <span class="red">a random number will be printed every 2 seconds.</span>
        </code></pre>
        <pre><code>
            setInterval(function(){
                const now = new Date();
                console.log(now);
            }, 1000)
        </code></pre>
        setInterval will continue to repeat the function over and over again, unless you save the setInterval value into
        an variable xxx, and then call clearInterval(xxx).

        <h4>filter Method</h4>
        <p>Creates a new array with all elements that pass the test implemented by the provided function.</p>
        <pre><code>
            const nums = [9,8,7,6,5,4,3,2,1];

            const odds = nums.filter(n => {
                return n % 2 === 1;
            });
            //[9,7,5,3,1]
        </code></pre>
        Which is the same as:
        <pre><code>
            const nums = [9,8,7,6,5,4,3,2,1];

            const odds = nums.filter(n => n%2===1);
            //[9,7,5,3,1]
        </code></pre>

        Combining maps and filter:

        <pre><code>
            const movies = [
            {
                title: 'Amadeus',
                score: 99,
                year: 1984
            },
            {
                title: 'Sharknado',
                score: 35,
                year: 2013
            },
            {
                title: '13 Going On 30',
                score: 70,
                year: 2004
            },
            {
                title: 'Stand by me',
                score: 85,
                year: 1986
            },
            {
                title: 'Parasite',
                score: 95,
                year: 2019
            }
            ]

            const goodMovies = movies.filter(movie => {
                return movie.score > 80;
            }) 
            <span class="red">will return an array formed by all movies with scores over 80</span>

            const goodTitles = goodMovies.map(movie => movie.title);
            <span class="red">this will return only the titles of the objects</span>

            const goodTitles = movies.filter(movie => movie.score > 80).map(movie => movie.title);
            <span class="red">this will return only the titles of the movies with scores higher than 80</span>
        </code></pre>

        <h4>Reduce Method</h4>
        <p>Reduces an array to a single value. The callback function has the following parameters:
            <br>.reduce(function(acc, cur, i, arr){
            <span class="red">function content</span>
            }, init);
            <br>acc -> is like a snowball, on each iteration keeps the returned value of the previous iteration;
            <br>cur -> the current item being iterated;
            <br>i -> the index of the current item;
            <br>init -> the inital value of the accumulator; default: 0;
        </p>
        <pre><code>
            <span class="red">Summing up all items of an array:</span>
            const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];
            const balance = movements.reduce(function (acc, cur, i, arr) {
                return acc + cur
            }, 0)
            
            console.log(balance);
            //3840

            <span class="red">Using arrow function:</span>
            const balance = movements.reduce((acc, cur) => acc + cur, 0);

            <span class="red">The same, using for...of loop:</span>
            let balance = 0;
            for (const mov of movements) balance += mov;
        </code></pre>
        <pre><code>
            <span class="red">Getting the maximum value out of an array:</span>
            const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];
            const max = movements.reduce((acc, mov) => {
                if (acc > mov)
                    return acc;
                else    
                    return mov;
            }, movements[0]);
            console.log(max);
            //3000
        </code></pre>


        <h4>Find Method</h4>
        <p>Basically equal to the filter method, but it only returns the first value.</p>
        <pre><code>
            const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];
            const firstWithdrawal = movements.find(mov => mov < 0);
            console.log(firstWithdrawal);
            //-400
        </code></pre>
        <p>Find method in objects:</p>
        <pre><code>
            const account1 = {
                owner: 'Jonas Schmedtmann',
                movements: [200, 450, -400, 3000, -650, -130, 70, 1300],
                interestRate: 1.2, // %
                pin: 1111,
              };
              
              const account2 = {
                owner: 'Jessica Davis',
                movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30],
                interestRate: 1.5,
                pin: 2222,
              };
              
              const account3 = {
                owner: 'Steven Thomas Williams',
                movements: [200, -200, 340, -300, -20, 50, 400, -460],
                interestRate: 0.7,
                pin: 3333,
              };
              
              const account4 = {
                owner: 'Sarah Smith',
                movements: [430, 1000, 700, 50, 90],
                interestRate: 1,
                pin: 4444,
              };
              
              const accounts = [account1, account2, account3, account4];

              const wantedAccount = accounts.find(account => account.owner === 'Jessica Davis');

              console.log(wantedAccount);
              //{
                owner: 'Jessica Davis',
                movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30],
                interestRate: 1.5,
                pin: 2222,
              }
        </code></pre>

        <h4>findIndex Method</h4>
        <p>This method is similar to .indexOf('x') method, but it accepts functions as an argument, and is used with
            arrays.</p>
        <pre><code>
            const account1 = {
                owner: 'Jonas Schmedtmann',
                movements: [200, 450, -400, 3000, -650, -130, 70, 1300],
                interestRate: 1.2, // %
                pin: 1111,
              };
              
              const account2 = {
                owner: 'Jessica Davis',
                movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30],
                interestRate: 1.5,
                pin: 2222,
              };
              
              const account3 = {
                owner: 'Steven Thomas Williams',
                movements: [200, -200, 340, -300, -20, 50, 400, -460],
                interestRate: 0.7,
                pin: 3333,
              };
              
              const account4 = {
                owner: 'Sarah Smith',
                movements: [430, 1000, 700, 50, 90],
                interestRate: 1,
                pin: 4444,
              };
              
              const accounts = [account1, account2, account3, account4];

              const index = accounts.findIndex(acc => acc.username === 'jd'); <span class="red">Here we are finding the index of the account that has 'jd' as its username.</span>

                accounts.splice(index, 1); <span class="red">Then we are removing this entire object from the accounts array.</span>
        </code></pre>

        <h4>every and some Methods</h4>
        <p>The every Method tests whether ALL elements in the array pass the provided function. It returns a boolean
            value.</p>
        <pre><code>
            const examsScores = [90,49,92,99,76,83];
            examsScores.every(score => score >= 60);
            //false
            <span class="red">it returned "false" because one score is less than 60</span>
        </code></pre>
        <p>The some Method is similar to every, but returns true if ANY of the array elements pass the test function.
        </p>
        <p>It is also similar to .includes method, but it accepts a function as its argument, while .includes only
            accepts a primitive.</p>
        <pre><code>
            const examsScores = [90,49,92,99,76,83];
            examsScores.some(score => score >=60);
            //true
            <span class="red">it returned "true" because at least one score is greater than 60</span>
        </code></pre>

        <h4>flat Method</h4>
        <p>Removes the nested arrays, flattening the entire array.</p>
        <pre><code>
            const arr = [[1,2,3],[4,5,6],7,8];
            console.log(arr.flat());
            //[1,2,3,4,5,6,7,8]

            const arrDeep = [[[1,2],3], [4,[5,6]],7,8];
            console.log(arrDeep.flat(2));
            <span class="red">The flat method accepts as its argument the number of levels of flattening.</span>
            //[1,2,3,4,5,6,7,8]

        </code></pre>

        <h4>.flatMap Method</h4>
        <p>This method consists in both .map and .flat method at the same time. It is used when the resulting array of
            map method has nested arrays inside. See Jonas #162</p>

        <h4>Sort (2/2)</h4>
        <p>In order to put numbers in ascending order, the sort method will return incorrect results, because it takes
            the numbers for strings (and,, for example, -1 will come before -3). For this purpose, we can use sort and
            pass a function as argument:</p>
        <pre><code>
            <span class="red">Ascending:</span>
            movements.sort((a, b) => {
                if (a > b) return 1;
                if (a < b) return -1;
            });

            <span class="red">Or:</span>
            movements.sort((a, b) => a - b);

            <span class="red">Descending:</span>
            movements.sort((a, b) => {
                if (a > b) return -1;
                if (a < b) return 1;
            });

            <span class="red">Or:</span>
            movements.sort((a, b) => b - a)
        </code></pre>

        <h4>Creating and filling arrays</h4>
        <pre><code>
            const x = new Array(7);
            console.log(7);
            //[empty x 7]

            x.fill(1);
            console.log(x);
            //[1,1,1,1,1,1,1]

            x.fill(1,3);
            console.log(x);
            //[empty x 3, 1, 1, 1, 1]

            x.fill(1,3,5);
            console.log(x);
            //[empty x 3, 1, 1, empty x 2]

            <span class="red">Array.from method</span>
            const y = Array.from({length: 7}, () => 2);
            console.log(y);
            //[2,2,2,2,2,2,2]

            const z = Array.from({length: 7}, (_, i) => i + 1)
            <span class="red">Inside the callback function, we always have access to the current item and the index - just as in map method.</span>

            <span class="red">Creating an array of 100 dice rolls</span>
            const ran = Array.from({length: 100}, num => Math.trunc(Math.random() * 6 + 1))

            <span class="red">The querySelectorAll method returns a node list, which isn't in fact an array. Array.from can convert node lists to arrays:</span>
            const movementsUI = Array.from(document.querySelectorAll('.movements__value'));
            <span class="red">Using the spread operator also will do the same:</span>
            const movementsUI2 = [...document.querySelectorAll('.movements__value')]
        </code></pre>
        <h2>Newer JS Features</h2>
        <h3>Default Param</h3>
        <p>Sets up a default argument for a given param in a function.</p>
        This is the old way of doing it:
        <pre><code>
            function rollDie(numSides) {
                if (numSides === undefined) {
                    numSides = 6;
                }
                return Math.floor(Math.random() * numSides) + 1;
            }
            <span class="red">creates a function where the user will have to input a numSides argument to choose the number of sides of the dice; if the user doesn`t choose any number, the number of sides will be 6</span>
        </code></pre>
        Using new defaut param feat:
        <pre><code>
            function rollDie(numSides = 6) {
                return Math.floor(Math.random() * numSides) + 1;
            }
            <span class="red">it's easy, just add "= defaultArgument"</span>
        </code></pre>

        <h3>Spread</h3>
        <p>Spread syntax (...) allows an iterable* such as an array to be <b>expanded</b> in places where zero or more
            arguments (for function calls) or elements (for array literals) are expected, or an object expression to be
            expanded in places where zero or more key-value pairs (for object literals) are expected.</p>
        <span class="red">* Iterables: strings, arrays, maps, sets, but NOT objects.</span>
        <p>Spread is similar to destructuring, but it won't create variables, and it is only useful in places that
            receives elements separated by comma.</p>
        <pre><code>
            Math.max(3,4,32,5,76,54,32345);
            //32345 <span class="red">this Math returns the higher number amongst its arguments.</span>
            
            const nums = [3,4,32,5,76,54,32345];
            Math.max(nums);
            //NaN
            Math.max(...nums);
            //32345
            <span class="red">Spand syntax (...) "spreads out" the elements of the array into separated arguments.</span>

            console.log(..."hello");
            //h e l l o

        </code></pre>

        <h4>Spread with arrays</h4>
        <p>Merging two arrays in a new array:</p>
        <pre><code>
            const cats = ['Jojo','Lili'];
            const dogs = ['Toto','Tutu'];

            const allPets = [...cats, ...dogs];
            allPets;
            //['Jojo','Lili','Toto','Tutu']
        </code></pre>

        <h4>Making a copy of an array using Spread</h4>
        <pre><code>
            const restaurant = {
                name: 'Classico Italiano',
                location: 'Via Angelo Tavanti, 23, Firenze, Italy',
                categories: ['Italian', 'Pizzeria', 'Organic'],
                starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
                mainMenu: ['Pizza', 'Pasta', 'Risotto']
            }

            const mainMenuCopy = [...restaurant.mainManu]; <span class="red">mainMenuCopy is assigned to ['Pizza', 'Pasta', 'Risotto']</span>

            const mainMenuPlus = [...restaurant.mainMenu, 'Gnocchi']; <span class="red">mainMenuCopy is assigned to ['Pizza', 'Pasta', 'Risotto', 'Gnocchi']</span>
        </code></pre>

        <h4>Merging two or more arrays</h4>
        <pre><code>
            const restaurant = {
                name: 'Classico Italiano',
                location: 'Via Angelo Tavanti, 23, Firenze, Italy',
                categories: ['Italian', 'Pizzeria', 'Organic'],
                starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
                mainMenu: ['Pizza', 'Pasta', 'Risotto']
            }

            const completeMenu = [...starterMenu, ...mainMenu];
        </code></pre>

        <h4>Spreading arrays inside of params</h4>
        <pre><code>
            const restaurant = {
                name: 'Classico Italiano',
                location: 'Via Angelo Tavanti, 23, Firenze, Italy',
                categories: ['Italian', 'Pizzeria', 'Organic'],
                starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
                mainMenu: ['Pizza', 'Pasta', 'Risotto'],

                orderPasta: function (ing1, ing2, ing3) {
                    console.log(`Here is your delicious pasta with ${ing1}, ${ing2} and ${ing3});
                } <span class="red">this is a method using the ingredients as params</span>
            }

            const ingredients = [
            prompt('Let/'s make pasta! Ingredient 1?'), 
            prompt('Ingredient 2?'), 
            prompt('Ingredient 3?')
            ]; <span class="red">building an array by asking the user to input 3 ingredients.</span>

            <span class="red">now let's call the method:</span>
            restaurant.orderPasta(ingredients[0], ingredients[1], ingredients[2]); <span class="red">this is the old way of doing it</span>
            restaurant.orderPasta(...ingredients) <span class="red">this is much better! The array will be spreaded into 3 elements, which will be the params ing1, ing2, ing3 in the method's function.</span>
        </code></pre>

        <h4>Spread with objects</h4>
        Copies proprieties from one object into another object. If there is a key that is present in both objects, the
        last object spreaded will win.

        <pre><code>
            const restaurant = {
                name: 'Classico Italiano',
                location: 'Via Angelo Tavanti, 23, Firenze, Italy',
                categories: ['Italian', 'Pizzeria', 'Organic'],
                starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
                mainMenu: ['Pizza', 'Pasta', 'Risotto']
            };

            const newRestaurant = {
                ...restaurant,
                founder: 'Giuseppe',
                foundedIn: 1999
            }
            <span class="red">The new object should contain the original object data, plus 2 new properties.</span>
        </code></pre>

        <h4>Making a copy of an object</h4>
        <pre><code>
            const restaurant = {
                name: 'Classico Italiano',
                location: 'Via Angelo Tavanti, 23, Firenze, Italy',
                categories: ['Italian', 'Pizzeria', 'Organic']
            }

            const restaurantCopy = { ...restaurant };
            <span class="red">creates a new copy of that object</span>

            restaurantCopy.name = 'Ristorante Roma';
            <span class="red">changes the value of 'name' property, and the original object remains unaltered!</span>
        </code></pre>

        <h3>Rest syntax</h3>
        <p>It can be saird that the Rest syntax does the opposite of the Spread syntax. The Rest syntax collects the
            remaining elements of an interable into an array.The Spread operator is used where otherwise we would see
            <b>values</b> separated by commas. On the other hand, the Rest operator is basically used where otherwise we
            would see <b>variable</b> names separated by commas.
        </p>
        <pre><code>
            const arr = [1, 2, ...[3, 4]];
            <span class="red">This ... stands for the spread syntax, because it is being used on the RIGHT side of =.</span>

            const [ a, b, ...others ] = [1, 2, 3, 4, 5];
            <span class="red">The others variable will be assigned to [3, 4, 5]. This ... stands for the Rest syntax, because it appears on the LEFT side of =.</span>
        </code></pre>


        <p>Captures the arguments of a function and hold them inside an array.</p>
        <pre><code>
            function raceResults(gold, silver, ...everyoneElse){
                console.log(`GOLD MEDAL GOES TO ${gold}`);
                console.log(`SILVER MEDAL GOES TO ${silver}`);
                console.log(`AND THANKS TO ${everyoneElse}`);
            }
            raceResults('Tammy','Tina','Trevor', 'Tony', 'Jack');
            //GOLD MEDAL GOES TO Tammy
            //SILVER MEDAL GOES TO Tina
            //AND THANKS TO Trevor, Tony, Jack

        </code></pre>

        <h3>Destructuring arrays</h3>

        <p>Destructuring is a way of unpacking values from an array or an object into separate variables. That is, to
            break a big data structure into smaller data structures. It is a non-destructive method.</p>
        <p>It is the same as calling an element from the array using array[0], but it can simplify the work.</p>
        <pre><code>
            const scores = [893898, 827832, 786367, 783454];
            
            let gold = score[0];
            let silver = score[1]; <span class="red">this is the old-fashioned way of doing it!</span>

            let [gold, silver] = scores;
            gold;
            //893898
            silver;
            //827832

            let [gold, silver, ...everyoneElse] = scores;
            gold;
            //893898
            silver;
            //827832
            everyoneElse;
            //[786367, 783454]

        </code></pre>

        <h4>Destructuting an array generated by a function</h4>
        <pre><code>
            const restaurant = {
                name: 'Classico Italiano',
                location: 'Via Angelo Tavanti, 23, Firenze, Italy',
                categories: ['Italian', 'Pizzeria', 'Organic'],
                starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
                mainMenu: ['Pizza', 'Pasta', 'Risotto'],

                order: function(starterIndex, mainIndex) {
                    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
                    <span class="red">the function order returns an array</span>
                }
            }

            const order1 = restaurant.order(2, 0);
            console.log(order1);
            //['Garlic Bread', 'Pizza']
            
            const [starterCourse, mainCourse] = rastaurant.order(2, 0); <span class="red">the returned array will be destructured into 2 variables</span>
            console.log(starterCourse, mainCourse);
            //Garlic Bread  Pizza
        </code></pre>

        <h4>Skipping elements and Destructing nested arrays</h4>
        <pre><code>
            const nested = [2, 4, [5, 6]];
            const [i, , j] = nested;
            <span class="red">the item 4 has been skipped; i is assigned to 2, j is assigned to [5,6]</span>
            const [x, , [y, z]] = nested;
            <span class="red">the item 4 has been skipped and the elements have been assigned one by one to its respective variables.</span>

        </code></pre>

        <h4>Setting defaults values to destructed variables</h4>
        <p>It is useful when we don't know the length of the array, then there won't be undefined values.</p>
        <pre><code>
            const [p=1, q=1, r=1] = [8, 9];
            <span class="red">p is assigned to 8, q is assigned to 9, r is assigned to 1.</span>
        </code></pre>

        <h3>Destructuring objects</h3>
        It is more common to use than deconstructuring arrays.
        <pre><code>
            const user = {
                email: 'harveym@gmail.com',
                password: 'jdhsjdh',
                firstName: 'Harvey',
                lastName: 'Milk',
                born: 1930,
                died: 1978,
                bio: 'Harvey Milk was an American politician.',
                city: 'San Francisco',
                state: 'California'
            }
            const first = user.firstName;
            const last = user.lastName; 
            <span class="red">this is the old way of doing!</span>
            const { firstName, lastName, email} = user;
            <span class="red">it will declare a new variable called firstName, etc. and assing the value "Harvey", etc. for them.</span>

            const { born: birthYear } = user;
            <span class="red">that will create a new variable called birthYear and assign the value of "born" key to it. That is used if you don't want the new variable to have the same name of the key.</span>
        </code></pre>

        <h4>Destructuring nested objects</h4>
        <pre><code>
            const restaurant = {
                name: 'Classico Italiano',
                location: 'Via Angelo Tavanti, 23, Firenze, Italy',
                categories: ['Italian', 'Pizzeria', 'Organic'],
                starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
                mainMenu: ['Pizza', 'Pasta', 'Risotto'],

                order: function(starterIndex, mainIndex) {
                    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
                },

                openingHours: {
                    fri: {
                        open: 12,
                        close: 22
                    },
                    sat: {
                        open: 11,
                        close: 23
                    },
                    sun: {
                        open: 11,
                        close: 22
                    }
                }
            }

            const {fri: {open, close}} = restaurant.openingHours;
            <span class="red">variable open will be created and assigned to 12, close will be assigned to 22.</span>
        </code></pre>

        <h4>Destructing objects inside of a method's params</h4>
        <pre><code>
            const restaurant = {
                name: 'Classico Italiano',
                location: 'Via Angelo Tavanti, 23, Firenze, Italy',
                categories: ['Italian', 'Pizzeria', 'Organic'],
                starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
                mainMenu: ['Pizza', 'Pasta', 'Risotto'],

                order: function(starterIndex, mainIndex) {
                    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
                },

                openingHours: {
                    fri: {
                        open: 12,
                        close: 22
                    },
                    sat: {
                        open: 11,
                        close: 23
                    },
                    sun: {
                        open: 11,
                        close: 22
                    }
                },

                orderDelivery: function ({starterIndex, mainIndex, time, address}) <span class="red">The parameter is an object that will be immediately destructured into 4 parameters.</span> {
                    console.log(`Order received! ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivered to ${address} at ${time}`)
                }
            }

            restaurant.orderDelivery({
                time: '22:30',
                address: 'Via del Sole, 21',
                mainIndex: 2,
                starterIndex: 2
            }); <span class="red">This is an ordered that was actually received. It is a function with ONE parameter, which is an object.</span>
            //'Order received! Garlic Bread and Risotto will be delivered to Via del Sole, 21 at 22:30'

        </code></pre>
        Same case, using default values:
        <pre><code>
            const restaurant = {
                name: 'Classico Italiano',
                location: 'Via Angelo Tavanti, 23, Firenze, Italy',
                categories: ['Italian', 'Pizzeria', 'Organic'],
                starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
                mainMenu: ['Pizza', 'Pasta', 'Risotto'],

                order: function(starterIndex, mainIndex) {
                    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
                },

                openingHours: {
                    fri: {
                        open: 12,
                        close: 22
                    },
                    sat: {
                        open: 11,
                        close: 23
                    },
                    sun: {
                        open: 11,
                        close: 22
                    }
                },

                orderDelivery: function ({starterIndex=0, mainIndex=0, time='20:00', address}) <span class="red">The parameter is an object that will be immediately destructured into 4 parameters.</span> {
                    console.log(`Order received! ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivered to ${address} at ${time}`)
                }
            }

            restaurant.orderDelivery({
                address: 'Via del Sole, 21',
                mainIndex: 2
            }); <span class="red">Here, the client did not specify the time and the starterIndex, so the system will assign default values.</span>
            //'Order received! Focaccia and Risotto will be delivered to Via del Sole, 21 at 20:00'
        </code></pre>

        <h4>Destructuring params</h4>
        Used to retrieve a few properties' values from an object.
        <pre><code>
            const user = {
                email: 'harveym@gmail.com',
                password: 'jdhsjdh',
                firstName: 'Harvey',
                lastName: 'Milk',
                born: 1930,
                died: 1978,
                bio: 'Harvey Milk was an American politician.',
                city: 'San Francisco',
                state: 'California'
            }
            <span class="red">To get the fullName of any user, there are 3 ways. First, using a regular function:</span>
            function fullName(user) {
                return `${user.firstName} ${user.lastName}`;
            }
            <span class="red">Second, deconstructing the object inside of function's block:</span>
            function fullName(user) {
                const { firstName, lastName } = user;
                return `${firstName} ${lastName};
            }
            <span class="red">Third, deconstructing the object inside of function's params:</span>
            function fullName({ firstName, lastName }) {
                return `${firstName} ${lastName}`;
            }
        </code></pre>
        Another example:
        <pre><code>
            const movies = [
            {
                title: 'Amadeus',
                score: 99,
                year: 1984
            },
            {
                title: 'Sharknado',
                score: 35,
                year: 2013
            },
            {
                title: '13 Going On 30',
                score: 70,
                year: 2004
            },
            {
                title: 'Stand by me',
                score: 85,
                year: 1986
            },
            {
                title: 'Parasite',
                score: 95,
                year: 2019
            }
            ]
            <span class="red">
            To filter only the movies with a score higher than 90, there are two ways. First using pure filter method:</span>
            movies.filter((movie) => movie.score >= 90);
            <span class="red">The second way is by using filter with deconstructed param.</span>
            movies.filter(({ score }) => score >= 90);
        </code></pre>
        Another example:
        <pre><code>
            const movies = [
            {
                title: 'Amadeus',
                score: 99,
                year: 1984
            },
            {
                title: 'Sharknado',
                score: 35,
                year: 2013
            },
            {
                title: '13 Going On 30',
                score: 70,
                year: 2004
            },
            {
                title: 'Stand by me',
                score: 85,
                year: 1986
            },
            {
                title: 'Parasite',
                score: 95,
                year: 2019
            }
            ]
            <span class="red">To create an array describing each movie, there are two ways. First, we can use a simple maps method:</span>
            movies.map(movie => {
                return `${movie.title}, released in ${movie.year} is rated ${movie.score}`;
            })
            <span class="red">Otherwise, we can create a map and destructure the objects` properties:</span>
            movies.map(({ title, score, year }) => {
                return `${title}, relased in ${year} is rated ${score}`;
            })
        </code></pre>

        <h4>Recursion</h4>
        <p>In computer science, recursion is a method of solving a problem where the solution depends on solutions to
            smaller instances of the same problem.</p>
        <p>Recursion is any situation where you do something, and depending on the results, you might do it again.
        </p>
        <p>Any iterator function (aka function with a loop) can be recursive instead.</p>
        <p>A recursive function is a function that, inside of its block, recalls itself.</p>
        Parts of a recursive function:
        function processDoll(doll) {
        //1) Base case: it stops the function to run if a condition is reached.
        if (found the piece of chocolate inside of the smallest doll)
        return "Yum yum";
        //2) Recursive call to itself.
        else
        processDoll(the smaller doll);
        }

        <h4>Short circuiting (&& and ||)</h4>
        <p>&& and || can be used to substitute simple if statements. This is called short-circuit evaluation.</p>
        <pre><code>
            ------|| OR------
            console.log(3 || 'Jonas');
            //3
            <span class="red">will return the first truthy value.</span>

            console.log('' || 'Jonas');
            //'Jonas'
            console.log(true || 0);
            //true
            console.log(undefined || null);
            //null
            <span class="red">both are falsy values, so the second is returned.</span>

            console.log(undefined || '' || 0 || 'Hello' || 23);
            //'Hello'

            -------&& AND-------
            console.log(0 && 'Jonas');
            //0
            <span class="red">will return the first falsy value.</span>
            
            console.log(7 && 'Jonas');
            //'Jonas'
            <span class="red">both values are truthy, so the second is returned.</span>

            console.log('Hello' && 23 && null && 'Jonas');
            //null

            <span class="red">It is used to substitute an if statement if we don't know if a certain element actually exists. For example, in rock-paper-scissors project:</span>
            document.querySelector('.newLine') && document.querySelector('.newLine').remove();
            <span class="red">the line only will be removed if it exists. This code prevents error message in the case of the .newLine class doesn't exist. The same could be done this way:
                if (document.querySelector('.newLine')) {
                    document.querySelector('.newLine').remove();
                };
            </span>
        </code></pre>

        <h4>Nullish Coalescing Operator (??)</h4>
        <p>Introduced in 2020. The same as || but it recognizes 0 as a truthy value. Nullish values are null and
            undefined. This operator only recognizes these as falsy.</p>
        <pre><code>
            let restaurant.numGuests = 0;
            guests = restaurant.numGuests || 10;
            console.log(guests);
            //10 
            <span class="red">|| recognizes 0 as a falsy value.</span>

            let restaurant.numGuests = 0;
            guests2 = restaurant.numGuests ?? 10;
            console.log(guests2);
            //0 
            <span class="red">?? recognizes 0 as a truthy value.</span>
        </code></pre>

        <h4>Logical assignment operators</h4>
        <p>Introduced in 2021.</p>
        <pre><code>
            ----------||=------------
            const rest1 = {
                name: 'Capri',
                numGuests: 20
            }
            const rest 2 = {
                name: 'La Piazza',
                owner: 'Giovanni Rossi'
            }

            To apply a property with a default value to all objects that still don't have this property:
            <span class="red">Using the || operator:</span>
            rest1.numGuests = rest1.numGuests || 10;
            rest2.numGuests = rest2.numGuests || 10;

            <span class="red">|| assigning operator:</span>
            rest1.numGuests ||= 10;
            rest2.numGuests ||= 10;

            -----------??=----------
            const rest1 = {
                name: 'Capri',
                numGuests: 0
            }
            const rest 2 = {
                name: 'La Piazza',
                owner: 'Giovanni Rossi'
            }
            <span class="red">using the ||=, 0 would be considered a falsy value and reassigned to 10.</span>
            rest1.numGuests ??= 10;
            rest2.numGuests ??= 10;
            <span class="red">using the ??= (nulish assignment operator) considers 0 to be a truthy value, and will mantain the 0 number of guests untouched :)</span>

            ----------&&=------------
            const rest1 = {
                name: 'Capri',
                numGuests: 20
            }
            const rest 2 = {
                name: 'La Piazza',
                owner: 'Giovanni Rossi'
            }
            <span class="red">To change the value of a property only if this property exists:</span>
            <span class="red">Using the && operator:</span>
            rest1.owner = rest1.owner && '<ANONYMOUS>';
            rest2.owner = rest2.owner && '<ANONYMOUS>';
            <span class="red">Using && assignment operator:</span>
            rest1.owner &&= '<ANONYMOUS>';
            rest2.owner &&= '<ANONYMOUS>'; 
                <span class="red">only rest2.owner will change.</span>

        </code></pre>

        <h4>Optional chaining ?.</h4>
        <p>Introduced in 2020. It is used when we don't know whether a property is present in a given object. It
            substitutes an if statement or a ternary operator.</p>
        <pre><code>
            const mon = restaurant.openingHours.mon?.open;
            <span class="red">we don't know whether this restaurant has the object mon inside of openingHours object. If it has, then the open property's value will be returned.</span>

            const restaurant = {
                name: 'Classico Italiano',
                location: 'Via Angelo Tavanti, 23, Firenze, Italy',
                categories: ['Italian', 'Pizzeria', 'Organic'],
                starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
                mainMenu: ['Pizza', 'Pasta', 'Risotto'],

                order: function(starterIndex, mainIndex) {
                    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
                },

                openingHours: {
                    fri: {
                        open: 12,
                        close: 22
                    },
                    sat: {
                        open: 11,
                        close: 23
                    },
                    sun: {
                        open: 11,
                        close: 22
                    }
                }
            }
            <span class="red">Checking which days does this restaurant open:</span>
            const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
            for (const day of days){
                const openYN = restaurant.openingHours[day]?.open;
                console.log(`On ${day}, we open at ${open}.`)
            }

            <span class="red">Checking if a method exists:</span>
            restaurant.order?.(0,1);
            <span class="red">Together with nulish coalescence operator:</span>
            restaurant.order?.(0,1) ?? 'Method does not exist.'

            <span class="red">Checking whether an array is empty:</span>
            const users = [{name: 'Jonas', email: 'hello@jonas.com'}];
            console.log(users[0]?.name ?? 'User array empty');
            <span class="red">without JS new features:</span>
            if(users.length > 0) console.log(users[0].name); else console.log('User array empty')
        </code></pre>

        <h4>Looping objects: object keys, values and entries</h4>
        <p></p>
        <pre><code>
            Object.keys(objectName)
            Object.values(objectName)
            Object.entries(objectName)
            <span class="red">These methods will return, respectively, an array with the keys, the values and the key-value pairs of the object.</span>

            <span class="red">to get entries of arrays, the syntax is different:</span>
            arrayName.entries()

            <span class="red">looping through an object:</span>
            const entries = Object.entries(openingHours);
            for (const x of entries){
                console.log(x)
            }

        </code></pre>

        <h4>Sets</h4>
        <p>Sets are a new data structure introduced in ES6. Sets contain unique values; are iterable; aren't indexed.
        </p>
        <pre><code>
            const ordersSet = new Set([
            'Pasta',
            'Pizza',
            'Pizza',
            'Risotto',
            'Pasta',
            'Pizza'
            ]);
            console.log(ordersSet);
            //{'Pasta', 'Pizza', 'Risotto'}

            console.log(ordersSet.size);
            //3

            ordersSet.has('Pizza');
            //true
            ordersSet.has('Bread');
            //false
            <span class="red">has method is similar to includes method in arrays.</span>

            ordersSet.add('Garlic Bread');

            ordersSet.delete('Pizza');

            <span class="red">There is no way to retrieve data from a set, we only can check if data is present or not.</span>

            <span class="red">Transforming a set into an array:</span>
            const ordersArray = [...ordersSet];
        </code></pre>

        <h4>Maps (data structure)</h4>
        <p>Maps can be compared to objects, but its "keys" can be of any type (strings, numbers, arrays, objects, maps
            etc).</p>
        <pre><code>
            const rest = new Map();
            <span class="red">creates an empty map.</span>
            rest.set('name', 'Classico Italiano');
            rest.set(1, 'Firenze, Italy');
            <span class="red">adding values to the map.</span>

            console.log(rest.set(2, 'Lisbon, Portugal'));
            <span class="red">.set not only adds values to the map, it also return the entire map:</span>
            //{'name' => 'Classico Italiano', 1 => 'Firenze, Italy', 2 => 'Lisbon, Italy'}

            rest
                .set('categories', ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'])
                .set('open', 11)
                .set('close', 23)
                .set(true, 'We are open :D')
                .set(false, 'We are closed :(');
            <span class="red">.set can be chained.</span>

            <span class="red">Maps' values can be retrieved with .get</span>
            console.log(rest.get('name'));
            //Classico Italiano
            console.log(rest.get(true));
            //We are open :D

            <span class="red">Checking if the restaurant is open in a given time:</span>
            const time = 21;
            console.log(rest.get(time > rest.get('open') && time < rest.get('close')));
            //We are open :D

            console.log(rest.has('categories'));
            //true
            <span class="red">.has checks if there is a given key on the map.</span>

            rest.delete(2)
            <span class="red">.delete deletes a key-value pair.</span>

            console.log(rest.size);
            //7

            rest.clear()
            <span class="red">map turns into an empty map.</span>
        </code></pre>

        <h5>Maps: iteration, etc.</h5>
        <pre><code>
            const question = new Map([
                ['question', 'What is the best programming language in the world?'],
                [1, 'C'],
                [2, 'Java'],
                [3, 'JavaScript'],
                ['correct', 3],
                [true, 'Correct!'],
                [false, 'Try again!']
            ]);

            <span class="red">Converting an object into a map:</span>
            const openingHoursMap = new Map(Object.entries(openingHours));

            <span class="red">Iterating through maps:</span>
            for (const [key, value] of question){ <span class="red">here we are deconstructing each array key-value into two variables.</span>
                if (typeof key === 'number'){
                    console.log(`Answer ${key}: ${value}`);
                }
            }

            <span class="red">Example: checking whether the prompted answer is correct:</span>
            const answer = Number(prompt('Your answer:'))
            if (answer === question.get('correct')){
                prompt(question.get(true))
            } else prompt(question.get(false));
            <span class="red">Jonas' solution:</span>
            const answer = Number(prompt('Your answer:'));
            console.log(question.get(question.get('correct') === answer));

            <span class="red">Convert map to array:</span>
            console.log(...question);
            console.log(...question.entries());
            console.log(...question.keys());
            console.log(...question.values());
        </code></pre>

        <h4>String methods (2/2) REVIEW</h4>
        <pre><code>
            const airline = 'TAP Air Portugal';
            const plane = 'A320';

            console.log(plane[0]);
            //B 
            console.log('B737'[2]);
            //3

            console.log(airline.length);
            //16
            console.log('B737'.length);
            //4

            console.log(airline.indexOf('r'));
            //6
            console.log(lastIndexOf('r'));
            //10
            console.log(indexOf('Portugal'));
            //8
            
            console.log(airline.slice(4));
            //Air Portugal
            console.log(airline.slice(4,7));
            //Air

            console.log(airline.slice(0, airline.indexOf[' ']));
            //TAP
            console.log(airline.slice(airline.lastIndexOf(' ')+1);
            //Portugal
            console.log(airline.slice(-2));
            //al
            console.log(airline.slice(1,-1));
            //AP Air Portuga
            
            <span class="red">Checking if airplain seat is a middle seat (last letter of seat is 'B' or 'E'):</span>
            const checkMiddleSeat = function(seat){
                const s = seat.slice(-1);
                if(s === 'B' || s === 'E'){
                    console.log('You got the middle seat :(');
                } else console.log('You got lucky!');
            }
            checkMiddleSeat('11B');
            //'You got the middle seat :('
            checkMiddleSeat('23C');
            //'You got lucky!'
            checkMiddleSeat('3E');
            //'You got the middle seat :('

        </code></pre>
        <p>Why do strings accept methods? Shouldn't methods only work on objects or arrays? That is because JS converts
            strings to objects. This automatic conversion is called BOXING.</p>

        <pre><code>
            <span class="red">Adjusting upper and lowercase in a proper name (capitalizing 1/2):</span>
            const passenger = 'jOnAS';
            const passengerLower = passenger.toLowerCase();
            const passengerCorrect = passengerLower[0].toUpperCase() + passengerLower.slice(1);
            console.log(passengerCorrect);

            <span class="red">As a function:</span>
            const adjustName = function(passengerName){
                return passenger.toLowerCase()[0].toUpperCase() + passenger.toLowerCase().slice(1);
            }
            console.log(adjustName('vItoR'));
            //Vitor
        </code></pre>
        <pre><code>
            <span class="red">Comparing e-mails:</span>
            const email = 'hello@jonas.io';
            const loginEmail = '   Hello@jonas.Io  \n' <span class="red">\n stands for press Enter key</span>

            const normalizedEmail = loginEmail.toLowerCase().trim
            console.log(email === normalizedEmail);
            //true
        </code></pre>
        <pre><code>
            <span class="red">Replacing pieces of strings:</span>
            const priceUK = '288,97£';
            const priceUS = priceUK.replace('£','$').replace(',','.');
            console.log(priceUS);
            //288.97$

            <span class="red">Replacing all occurances:</span>
            const announcement = 'All passengers come to boarding door 23. Boarding door 23!';
            console.log(announcement.replace(/door/g, 'gate'));
            <span class="red">/g is a regular expression.</span>
        </code></pre>
        <pre><code>
            <span class="red">Methods that return booleans:</span>
            const plane = 'Airbus A320neo';
            
            console.log(plane.includes('A320'));
            //true
            console.log(plane.includes('Boeing'));
            //false
            console.log(plane.startsWith('Air'));
            //true

            if (plane.startsWith('Airbus') && plane.endsWith('neo')){
                console.log('Part of the NEW Airbus family');
            }
        </code></pre>
        <pre><code>
            console.log('a+very+nice+string'.split('+'));
            //['a', 'very', 'nice', 'string']

            console.log('Jonas Schmedtmann'.split(' '));
            //['Jonas', 'Schmedtmann']

            <span class="red">Destructuring the resulting array of split method to obtain 2 variables:</span>
            const [firstName, lastName] = 'Jonas Schmedtmann'.split(' ');

            const newName = ['Mr.', firstName, lastName.toUppercase()].join('---');
            console.log(newName);
            //Mr.---Jonas---SCHMEDTMANN
            <span class="red">The join() method is the opposite of the split() method.</span>

            <span class="red">Capitalizing (2/2) a long name:</span>
            const capitalizeName = function(name){
                const names = name.split(' ');
                const namesUpper = [];
                for(const n of names) {
                    namesUpper.push(n[0].toUpperCase() + n.slice(1)); <span class="red">this part can also be written like this: namesUpper.push(n.replace(n[0], n[0].toUpperCase()))</span>
                } 
                console.log(namesUpper.join(' '));
            }
            capitalizeName('jessica ann smith davidson');
            //Jessica Ann Smith Davidson 
        </code></pre>
        <pre><code>
            <span class="red">Padding a string (adding a number of character into the string until the string has a certain desired length):</span>
            const message = 'Go to gate 23!';
            console.log(message.padStart(25, '+').padEnd(30, '+'));
            //+++++Go to gate 23!++++++++++

            <span class="red">Masking a credit card number:</span>
            const maskCred = function(number){
                const str = number + ''; <span class="red">this converts the number into a string</span>
                const lastFour = str.slice(-4);
                return lastFour.padStart(srt.length, '*');
            }
            console.log(maskCred(736627288373882));
            //***********3882

            <span class="red">Repeat:</span>
            const message2 = 'Bad weather... All departures delayed...'
            console.log(message.repeat(5));
            //Bad weather... All departures delayed...Bad weather... All departures delayed...Bad weather... All departures delayed...Bad weather... All departures delayed...Bad weather... All departures delayed...

            
        </code></pre>

        <h3>ARRAY METHODS (Jonas)</h3>
        <h4>forEach method</h4>
        <p>Basically the same as for...of loops. Accepts a callback function. The parameters of this callback function
            are, by default: (1st, 2nd, 3rd), 1st being the item, 2nd being the item's index, 3rd being the entire
            array.</p>
        <pre><code>
            const movements = [200, -400, 100];

            <span class="red">Using for...of:</span>
            for (const movement of movements) {
                if (movement < 0){
                    console.log(`You deposited ${movement}`);
                } else {
                    console.log(`You withdrew ${Math.abs(movement)}`);
                }
            }

            <span class="red">Using forEach:</span>
            movements.forEach(function (movement) {
                if (movement < 0){
                    console.log(`You deposited ${movement}`);
                } else {
                    console.log(`You withdrew ${Math.abs(movement)}`);
                }
            })

            <span class="red">To obtain also the index of each item, using for...of:</span>
            for (const [i, movement] of movements.entries()) {
                if (movement < 0){
                    console.log(`Movement ${i+1} You deposited ${movement}`);
                } else {
                    console.log(`Movement ${i+1} You withdrew ${Math.abs(movement)}`);
                }
            }

            <span class="red">Obtaining also the index, using forEach:</span>
            movements.forEach(function (movement, i) {
                if (movement < 0){
                    console.log(`Movement ${i+1} You deposited ${movement}`);
                } else {
                    console.log(`Movement ${i+1} You withdrew ${Math.abs(movement)}`);
                }
            })

        </code></pre>

        <h5>forEach with Maps and Sets</h5>
        <p>When using forEach with maps, the function's parameters will correspond to the Map's value, key, entireMap -
            respectively.</p>
        <pre><code>
            const currencies = new Map([
            ['USD', 'United States Dollar'],
            ['EUR', 'Euro'],
            ['GBP', 'Pound Sterling']
            ]);
            currencies.forEach(function(value, key, map){
                console.log(`${key}: ${value}`);
            })
            //USD: United States Dollar
            //EUR: Euro
            //GBP: Pound Sterling
        </code></pre>
        <p>When using forEach with sets, the function's parameters will correspond to the Set's value, value again,
            entireMap - respectively. There are two value parameters, which are the same, just because sets don't have
            keys.</p>
        <pre><code>
            const currenciesUnique = new Set(['USD', 'GBP', 'USD', 'EUR', 'EUR']);
            currenciesUnique.forEach(function (value, _, set){
                console.log(`${value})
            })
        </code></pre>

        <h3>NUMBERS, DATES, TIMERS, INTL (Jonas sc12)</h3>
        <h4>Numbers methods</h4>
        <pre><code>
            Number.parseInt('23')
            //23
            Number.parseFloat('  2.5rem   ')
            //2.5
            <span class="red">best choice to get a number from a string like CSS values.</span>

            Number.isNaN('23');
            //true
            Number.isFinite(23)
            //true
            <span class="red">best choice to check if a value is a number.</span>

            Number.isInteger(23);
            //true
        </code></pre>
        <h4>Math methods</h4>
        <pre><code>
            Math.sqrt(25)
            //5
            25 ** (1/2)
            //5
            8 ** (1/3)
            //2

            Math.max(2,5,6,3,44,5)
            //44
            Math.min(2,3,6,4,0.2,4)
            //0.2

            Math.PI * Number.parseFloat('10px') ** 2)
            <span class="red">calculates the area of a circle with 10px radius</span>

            Math.floor(Math.random() * 6) + 1
            //random number from 1 to 6

            const randomInt = (min, max) => Math.floor(Math.random() * (max - min) + 1) + min;
            //random number from min to max
            
            Math.round(23.3)
            //23
            Math.round(23.9)
            //24

            Math.ceil(23.5)
            //24

            Math.floor(23.7)
            //23
            Math.floor('23.4')
            //23

            Math.trunc(23.33432223)
            //23
            <span class="red">just deletes the decimals</span>

            (2.7).toFixed(2)
            //2.70
            (2.783728).toFixed(3)
            //2.783
        </code></pre>

        <h4>Dates and times
        </h4>
        <pre><code>
            <span class="red">Create a date</span>
            const now = new Date(); <span class="red">will give the time from now</span>

            console.log(new Date('Aug 02 2020 18:05;41'))
            <span class="red">returns the complete date, including weekday and timezone</span>
            //Sun Aug 02 2020 18:05:41 GMT+0100 (Western European Summer Time)

            console.log(new Date(2037, 10, 19, 15, 23, 5));
            //Thu Nov 19 2037 15:23:05 GMT+0000 (Western European Standard Time)
            <span class="red">the month is 0-based, so month 10 is Nov</span>

            console.log(new Date(0));
            //Thu Jan 01 1970 01:00:00 GMT+0100 (Western European Standard Time)
            <span class="red">the first second in Unix-time</span>

            console.log(new Date(3 * 24 * 60 * 60 * 1000));
            //Sun Jan 04 1970 01:00:00 GMT+0100 (Western European Standard Time)
            <span class="red">3 days after first Unix-time</span>
        </code></pre>

        <p>Date methods:</p>
        <pre><code>
            const future = new Date(2037, 10, 19, 15, 23);
            future.getFullYear();
            //2037

            future.getMonth();
            //10
            <span class="red">the month is 0-based!</span>

            future.getDate();
            //19
            <span class="red">this is the day of the month</span>

            future.getDay();
            //4 
            <span class="red">(day of the week, 0 is Sunday)</span>

            future.getHours();
            future.getMinutes();
            future.getSeconds();

            future.toISOString();
            //2037-11-19T15:23:00.000Z
            <span class="red">date in ISO International Standard format</span>

            future.getTime();
            //2142256980000
            <span class="red">total of miliseconds passed after the first Unix day (1970). This timestamp also can be created like this:</span>
            Date.now();

            future.setFullYear(2040);
            <span class="red">changes the year to 2040</span>
        </code></pre>
        <p>Operations with dates:</p>
        <pre><code>
            const future = new Date(2037, 10, 19, 15, 23);
            console.log(+future);
            <span class="red">converts a date to a timestamp (transcurred time from Unix-day in 1970, in miliseconds</span>
            //2142256980000

            <span class="red">How many days from 14/3/2037 to 24/3/2037?</span>
            const calcDaysPassed = (date1, date2) => Math.abs(date1 - date2) / (1000 * 60 * 60 * 24);
            
            const days1 = calcDaysPassed(new Date(2037, 3, 14), new Date(2037, 3, 24));
            console.log(days1);
            //10

            
        </code></pre>
        For more precise date calculations, use Moment.JS library.

        <h4>Internationalization of dates, numbers, etc.</h4>
        <p>We can use the JS Internationalization API to format dates, numbers, etc, according to the language and
            country of the user.</p>
        <pre><code>
            const now = new Date();
            labelDate.textContent = new Intl.DateTimeFormat('en-US').format(now);
            <span class="red">This will format the date in the stardard US pattern: 7/12/2022 (month/day/year)</span>
            <br><span class="red">For other language-country codes: <a href="http://www.lingoes.net/en/translator/langcode.htm"> http://www.lingoes.net/en/translator/langcode.htm</a></span>
        </code></pre>
        <p>Adding more datails to the date: day of the week, hour, etc.:</p>
        <pre><code>
            const now = new Date();
            const options = {
                hour: 'numeric',
                minute: 'numeric',
                day: 'numeric',
                month: 'long',
                year: 'numeric',
                weekday: 'long'
            }
            labelDate.textContent = new Intl.DateTimeFormat('en-US', options).format(now);
            <span class="red">Date will be shown as: Wednesday, August 12, 2020, 8:40 AM</span>

            <span class="red">Getting the local from the user's browser:</span>
            const now = new Date();
            const options = {
                hour: 'numeric',
                minute: 'numeric',
                day: 'numeric',
                month: 'long',
                year: 'numeric',
                weekday: 'long'
            }
            const locale = navigator.language;
            labelDate.textContent = new Intl.DateTimeFormat(locale, options).format(now);
        </code></pre>
        <p>Internationalization of currencies and other units:</p>
        const num = 342635363.23
        const options = {
        style: currency,
        currency: 'EUR'
        };
        console.log(new Intl.NumberFormat('de-DE', options).format(num));
        //€ 342.635.363,23

        <span class="red">Other units:</span>
        const num = 342635363.23
        const options = {
        style: unit,
        unit: 'mile-per-hour'
        };
        console.log(new Intl.NumberFormat('de-DE', options).format(num));
        //342.635.363,23 mp/h

        <h2>DOM</h2>
        <p>Stands for 'Document Object Model'.</p>
        <h3>Selecting elements, classes etc.</h3>
        <pre><code>
            document.documentElement
            document.head 
            document.body 

            
            getElementById('idOfTheElement')
            getElementByTagName('img') 
            getElementByClassName('classname')
            <span class="red">These selectors return an HTML live Collection, which is always uptodate.</span>

            querySelector('.classname'), querySelector('#idname'), querySelector('element'),
            querySelector('element[attribute="value"]')
            querySelectorAll
        </code></pre>
        <h3>Selecting the text content</h3>
        <pre><code>
            document.querySelector('p').innerText <span class="red">selects readable text</span>
            document.querySelector('p').textContent <span class="red">selects readable text with markups applied</span>
            document.querySelector('p').innerHTML <span class="red">selects HTML code</span>
        </code></pre>
        <h3>Selecting and manipulating attributes</h3>
        <pre><code>
            document.querySelector('element').attribute; <span class="red">simply calls the attribute</span>
            document.querySelector('element').attribute = 'newValue'; <span class="red">defines a new value to the attribute</span>
            Eg:
            document.querySelector('#banner').src = "anotherchickenIMG.img"; 
            document.querySelector('#banner').id = "anotherID";

            document.querySelector('element').getAttribute('attribute') <span class="red">checks if there is that attibute and returns its value</span>

            document.querySelector('element').setAttribute('attribute', 'value'); <span class="red">creates an new attribute and its value</span>

            elementIMG.src
            <span class="red">returns the absolute source address</span>
            elementIMG.getAttribute('src')
            <span class="red">returns the relative source address</span>

            <span class="red">Data attributes:
                on HTML:
                <img data-version-number = "3.0">
                On JS:
            </span>
            elementIMG.dataset.versionNumber;
            //3.0

            element.dataset.versionNumber;

        </code></pre>

        <h3>Changing (CSS) styles</h3>
        <pre><code>
            document.querySelector('element').style.backgroundColor = 'purple'; 

            window.getComputedStyle(document.querySelector('element')).color <span class="red">accesses the actual computed styles of that element (if there are styles applied using html, css and js, for ex.)</span>

            element.style.height = Number.parseFloat(getComputedStyle(element).height, 10) + 30 + 'px';
            <span class="red">Adds 30px to the actual computed height.</span>
        </code></pre>
        <p><b>Defining variables in CSS:</b> Defining variables in CSS, we can call these values wherever we want, both
            in CSS file and in JS file (when defining CSS style using JS). The root in CSS is equivalent to document in
            DOM or window in JS..</p>
        <pre><code>
            <span class="red">in the beginning of the CSS file:</span>
            :root {
                --color-primary: #5ec576;
                --color-secundary: #ffcb03;
                --gradient-primary: linear-gradient(to top left, #39b385, #9be15d);
            }

            <span class="red">Then, in JS...</span>

            element.style.setProperty('--color-primary', 'orangered');
            <span class="red">changes the root in CSS, substituting all --color-primary (property) for orangered (value).</span>
        </code></pre>

        <h3>classList</h3>
        <pre><code>
            document.querySelector('element').setAttribute('class', 'classname'); <span class="red">already seen</span>

            document.querySelector('element'). classList <span class="red">lists the classes</span>
            document.querySelector('element'). classList.add('classname') <span class="red">add a new class</span>
            classList.add('classname1', 'classname2') <span class="red">add 2 new classes</span>
            document.querySelector('element').classList.remove('classname') <span class="red">removes the class</span>
            document.querySelector('element').classList.toggle('classname') <span class="red">adds/remove the class, depending on the case</span>
            document.querySelector('element').classList.contains('classname') <span class="red">checks if the class is applied, returns boolean</span>
        </code></pre>

        <h3>Parent / Child / Sibling (DOM Traversing)</h3>
        <pre><code>
            <span class="red">PARENT:</span>
            document.querySelector('element').parentElement

            document.querySelector('element').closest('.header') <span class="red">selects the closest parent with the .header class</span>
            document.querySelector('element').closest('element') <span class="red">selects the element itself</span>

            <span class="red">CHILDREN:</span>
            document.querySelector('element').childElementCount <span class="red">counts the number of childs of the element</span>
            document.querySelector('element').children <span class="red">lists the children</span>
            document.querySelector('element').children[0] <span class="red">returns the first child</span>
            
            <span class="red">SIBLINGS:</span>
            document.querySelector('element').previousSibling <span class="red">returns the previous DOM node (it can be only an empty line)</span>
            document.querySelector('element').nextSibling
            document.querySelector('element').previousElementSibling <span class="red">returns the previous element sibling MOST USED</span>
            document.querySelector('element').nextElementSibling <span class="red">returns the next element sibling MOST USED</span>
            document.querySelector('element').parentElement.children <span class="red">selects all the siblings, including the element itself</span>
            [...element.parentElement.children].forEach(function (el) {
                if (el !== h1) el.style.color = 'grey';
            }); <span class="red">turns every sibling of element into grey color, except for the element itself</span>
            
        </code></pre>

        <h3>Creating / inserting elements</h3>
        <pre><code>
            .insertAdjacentHTML('<p>text here</p>');

            const newEl = document.createElement('div');
            newEl.classList('cookie-message');
            newEl.textContent = 'We use cookies for improved functionality and analytics.';
            newEl.innerHTML = 'We use cookies for improved functionality and analytics. <button class="btn btn--close-cookie">Got it!</button>';

            element.prepend(newEl);
            <span class="red">Adds newEl as the first child of element.</span>
            element.append(newEl);
            <span class="red">Adds newEl as last child of element..</span>

            element.append(newEl.cloneNode(true));
            <span class="red">Newly created elements can only be inserted once, so if you want to append more than one, you have to first make a copy, using .cloneNode(true); "true" means that all element's children will be copied.</span>

            element.after(newEl);
            <span class="red">Adds newEl as a sibling of element, after it.</span>
            element.before(newEl);
            <span class="red">Adds newEl as a sibling of element, before it.</span>

            newEl.remove();
            <span class="red">Deletes the newEl.This is a recent method; before, we would have to select the parent and remove a child:</span>

            newEl.parentElement.removeChild(newEl);


        </code></pre>

        <h3>append / appendChild</h3>
        <pre><code>
            document.createElement('img') <span class="red">creates an img element, but it's still nowhere on the page</span>

            const newImg = document.createElement('img');
            newImg.src = 'http://www.hjh.com/img.png';

            document.body.appendChild(newImg); <span class="red">appends the img as the last child on the body</span>

            document.querySelector('element').append('new text!'); <span class="red">appends the text on the string next to that element. The append method is more flexible than the appendChild!</span>
            document.querySelector('element').append('new text!', 'new text too!'); <span class="red">appends 2 pieces of text</span>

            document.querySelector('element').prepend(newImg); <span class="red">prepends the newly created newImg as the first child of this element</span>

            document.querySelector('element').insertAdjacentElement(beforebegin, 'otherElement');
            document.querySelector('element').insertAdjacentElement(afterbegin, 'otherElement!');
            document.querySelector('element').insertAdjacentElement(beforeend, 'otherElement!');
            document.querySelector('element').insertAdjacentElement(afterend, 'otherElement!'); <span class="red">append otherElement after the end of the element-target</span>

            document.querySelector('element').after('otherElement'); <span class="red">appends otherElement after the element-target</span>
        </code></pre>
        <p>Another way for appending code to the HTML is using the .insertAdjacentHTML method. It accepts two strings as
            parameters: one is the position 'beforebegin' 'afterbegin' 'beforeend' 'afterend', the other is the HTML
            code itself (usually inside of a variable). See Jonas 147.</p>

        <h3>Remove element</h3>
        <pre><code>
            document.querySelector('body').removeChild('img'); <span class="red">removes the first image that is a child of body</span>

            document.querySelector('element').remove; <span class="red">removes the element</span>
        </code></pre>

        <h3>Events</h3>

        <h4>Inline events</h4>
        Directly on HTML code. Not recommended.
        <pre><code>
            <button onclick="alert('You clicked me!')">Click Me</button>

            <button onclick="alert('You clicked me!'); alert('Stop clicking me!'">Click Me</button>
        </code></pre>

        <h4>The onclick property</h4>
        On JS file:
        <pre><code>
            const btn2 = document.querySelector('#btn2');
            btn2.onclick = function(){
                console.log('You clicked me!');
                console.log('I hope it worked!');
            }

            btn2.onmouseenter = function(){
                console.log('Click click!');
            } <span class="red">onmouseenter is just equivalent to hover</span>

            btn2.onclick = () => console.log('Using arrow function!');
        </code></pre>

        <h4>The addEventListener method</h4>
        Best choice.
        <pre><code>
            btn3 = document.querySelector(#btn3);

            btn3.addEventListener('click', function(){
                alert('Clicked!');
            })

            btn3.addEventListener('dblclick', () => console.log('Arrow!'));
        </code></pre>
        Besides 'click', there are other parameters such as 'mouseenter', 'mouseleave', 'dblclick' etc.
        PS: 'mouseenter' doesn't bubble, 'mouseover' is the same, but it bubbles, so that it can be used in Event
        Delegation. The opposite of 'mouseenter' is 'mouseleave', the opposite of 'mouseover' is 'mouseout'.

        <h5>Removing event listener</h5>
        <p>If we want the event listener to work only once:</p>
        <pre><code>
            const h1 = document.querySelector('h1');
            const alertH1 = function(e) {
                alert('Great!');
                h1.removeEventListener('mouseenter', alertH1);
            }
            h1.addEventListener('mouseenter', alertH1);
        </code></pre>


        <h4>Keyboard event & Event Objects</h4>
        <pre><code>
                document.addEventListener('keydown', function (e) {
                    if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
                        closeModal();
                    }
                })
                <span class="red">
                The 'e' parameter receives the key that was pressed. The 'e.key' is a property of the object e, and refers to the actual key that was pressed.</span>
                <br>
                <span class="red">The 'e' object also has a e.code property, this refers to the code of the key that was pressed, and is useful if the users are from different countries that use different keyboard settings. </span>

                window.addEventListener('keydown', function() {
                    switch (e.code) {
                        case 'ArrowUp':
                            console.log('UP!');
                            break;
                        case 'ArrowDown':
                            console.log('DOWN!');
                            break;
                        case 'ArrowLeft':
                            console.log('LEFT!');
                            break;
                        case 'ArrowRight':
                            console.log('RIGHT!');
                            break;
                        default:
                            console.log("IGNORED!")
                    }
                }) <span class="red">this code may be useful to make a first person role play game</span>
            </code></pre>

        There is also a 'keydown' parameter, that refers to when the key is released after being pressed.

        <h4>Form Events & PreventDefault</h4>
        <pre><code>
                const form = document.querySelector('#myForm');
                const input = document.querySelector('#inputtext');
                const list = document.querySelector('ul');

                form.addEventListener('submit', function(e){
                    e.preventDefault(); <span class="red">this line prevents that the default behavior when submitting a form is executed. The default behavior use to be go to the address where the form is being submitted.</span>
                    <span class="red">Now let's use the input data to append new text to the page:</span>
                    const newLI = document.createElement('li'); <span class="red">creates a new empty li</span>
                    newLI.innerText = input.value; <span class="red">sets the input value to be the inner text of the new element</span>
                    list.append(newLI); <span class="red">append the li to the list on the page</span>
                    input.value = ''; <span class="red">resets the input value to empty</span>
                })
            </code></pre>

        <h4>Change & Input Events</h4>
        <p>Change events are executed whenever the user changes the value of input AND moves the cursor out of the input
            field (when the input is BLURED).</p>
        <pre><code>
                const input = document.querySelector('input');

                input.addEventListener('change', function (e) {
                    console.log('Changed the value!')
                })
            </code></pre>
        <p>Input events fires as soon as the user types something on the input.</p>
        <pre><code>
                const input = document.querySelector('input');

                input.addEventListener('input', function (e) {
                    console.log('Input event!');
                })
            </code></pre>
        <p>Input events can be used to live-sync the value of input on a page element:</p>
        <pre><code>
                const input = document.querySelector('input');
                const h1 = document.querySelector('h1');

                input.addEventListener('input', function (e) {
                    h1.innerText = input.value;
                })
            </code></pre>


        <h4>scrollTo method</h4>
        <p>Finding the coordinates:</p>
        <pre><code>
            element.getBoundingClientRect();
            <span class="red">returns the DOMRect object, which contains the x and y coordinates of that element. The x and y coordinates are the CURRENT position of that element on the client viewport.</span>

            window.pageXOffset
            window.pageYOffset
            <span class="red">returns the x and y coordinates of the area currently displayed on the client viewport. Y refers to the distance from the top of the page to the top of the currently viewed area.</span>

            window.scrollY
            window.scrollX
            <span class="red">the same as pageYOffset and pageXOffset</span>

            document.documentElement.clientHeight 
            document.documentElement.clientWidth 
            <span class="red">returns the current height and width of the client viewport.</span>
        </code></pre>
        <p>.scrollTo method:</p>
        <pre><code>
            window.scrollTo(
                element.getBoundingClientRect().left + window.pageXOffset, 
                element.getBoundingClientRect().top + window.pageYOffset);

            window.scrollTo({
                left: element.getBoundingClientRect().left + window.pageXOffset, 
                top: element.getBoundingClientRect().top + window.pageYOffset),
                behavior: 'smooth'
            })
            <span class="red">implements smooth scroll to that element</span>
        </code></pre>
        <p>More modern way of scroll to:</p>
        <pre><code>
            section1.scrollIntoView({behavior: 'smooth'});
            <span class="red">simple and easy!</span>

            <span class="red">Complete code of event:</span>
            const btnScrollTo = document.querySelector('.btn--scroll-to');
            const section1 = document.querySelector('#section--1');
            btnScrollTo.addEventListener      ('click', function () {
                section1.scrollIntoView({ behavior: 'smooth' });
})
        </code></pre>

        <h4>Scroll events</h4>
        <p>There are two methods for doing scroll events. The first one is not that good, because the scroll argument in
            the addEventListener function keeps reading every scrolling that the user makes on the page:</p>
        <pre><code>
            const initialCoords = section1.getBoundingClientRect();

            window.addEventListener('scroll', function () {
                if (this.window.scrollY > initialCoords.top) nav.classList.add('sticky');
                else nav.classList.remove('sticky');
            });
        </code></pre>

        <h4>.getBoundingClientRect() </h4>
        <p>This is a DOM method that returns an object with several key/value pairs with information about the element's
            size and positioning within the webpage.</p>
        <pre><code>
            element.getBoundingClientRect();
            //{
                top: 450,
                left: 400,
                right: 825,
                bottom: 500,
                x: 400,  
                y: 450,  
                width: 425,
                height: 50
              }
        </code></pre>

        <h4>Intersection Observer API</h4>
        <p>Enables that an element can be "observed", and notifies when the element enters or leaves the viewport.</p>
        <pre><code>
            const header = document.querySelector('.header');
            const navHeight = nav.getBoundingClientRect().height;

            const stickyNav = function (entries) {
            const [entry] = entries;
            console.log(entry);
                if (!entry.isIntersecting) nav.classList.add('sticky'); else nav.classList.remove('sticky');
            }
            <span class="red">this function is used as an argument of the observer, and will be called whenever the observed element (header) intersects the root (viewport) at the threshold that we defined.</span>

            const headerObserver = new IntersectionObserver(<b>stickyNav</b>, {
                root: null, <span class="red">selects the viewport as the root</span>
                threshold: 0, <span class="red">the percentage of intersection at which the callback function will be called; if this value is set to an array, for example, [0, 0.2], then the callback function will be called whenever the target moves completely out of the view (0) and also when it enters the view (0.2)</span>
                rootMargin: `-${navHeight}px` <span class="red">sets a "margin" to the root</span>
            }); <span class="red">the options object can be defined separately as a variable</span>
            headerObserver.observe(header); <span class="red">don't forget to call the observer with the element to be observed as an argument.</span>
        </code></pre>
        <p>See Reveal hidden sections as user scrolls page, on Jonas lecture 198, lazy imgs 199, slide carousel 200/201.
        </p>

        <h4>Event Bubbling</h4>
        <p>When there are two or more eventListeners triggered by a click, we can prevent it to propagate (bubbling) by
            adding the code <b>e.stopPropagation()</b> to the function of the first eventListener's function. </p>

        <h4>Event Delegation</h4>
        <p>Sets an event when the specific target is clicked.</p>
        <p>Useful to set events for elements which are not present on the page when it is loaded.</p>
        <pre><code>
            <span class="red">Using .forEach to add eventListeners to several elements in a navbar and setting them to scroll each to a specific id section on the page:</span>
            document.querySelectorAll('.nav__link').forEach(function (el) {
                el.addEventListener('click', function (e) {
                    e.preventDefault();
                    const id = this.getAttribute('href');
                    document.querySelector(id).scrollIntoView({behavior: 'smooth'});
                });
            });
            <span class="red">This method works ok, but for a large number of elements it can make the page too heavy to load. Besides, it can't set events to elements that at the loading of the page, still are not created. That's why the Event Delegation is useful:</span>

            document.querySelector('.nav__links')<span class="red">this is the parent element to the targeted elements</span>.addEventListener('click', function (e) {
                e.preventDefault();
                <span class="red">Mathing strategy:</span>
                if (e.target.classList.contains('nav__link')) {
                    const id = e.target.getAttribute('href');
                    document.querySelector(id).scrollIntoView({behavior: 'smooth'});
                }
            });
        </code></pre>
        <p>Guard clause: if the user clicks an area of the parent element that is outside of any target, the function
            stops; it is the same as envolve the rest of the function inside a if(target) block.</p>
        <pre><code>
            const tabs = document.querySelectorAll('.operations__tab');
            const tabsContainer = document.querySelector('.operations__tab-container');
            const tabsContent = document.querySelectorAll('.operations__content');

            tabsContainer.addEventListener('click', function(e) {
            const clicked = e.target.closest('.operations__tab');
            console.log(clicked);

            <span class="red">Guard clause (if the user clicks an area of the tab-container that is outside of any button, the function stops; it is the same as envolve the rest of the function inside a if(clicked) block;):</span> 
            if(!clicked) return;

            clicked.classList.add('operations__tab--active');
})
        </code></pre>

        <h4>Lifecycle DOM Events</h4>
        <pre><code>
            document.addEventListener('DOMContentLoaded', function (e){
                console.log('HTML parsed and DOM tree built!', e);
            });

            window.addEventListener('load', function (e){
                console.log('Page fully loaded', e);
            });

            window.addEventListener('beforeunload', function (e){
                e.preventDefault();
                console.log(e);
                e.returnValue = '';
            })
            <span class="red">This one is useful to prevent user to leave the website when filling forms, etc. It prompts an alert alerting changes have been made and changes will be lost if leave page.</span>
        </code></pre>

        <h3>OOP Object Oriented Programming</h3>
        <p>A joke:</p>
        OOP
        <br> which kind of coding paradigm do you prefer?
        <br> A) OOP
        <br> B) FP
        <br> C) Spaghetti code <br>

        <h4>Constructor Functions</h4>
        <ol>
            <li>New object is created</li>
            <li>When function is called, this keyword is the newly created object</li>
            <li>The object is linked to prototype
            </li>
            <li>Function automatically returns the object</li>
        </ol>

        <pre><code>
            const Person = function (first, birth) {
                this.firstName = first;
                this.birthYear = birth;
            };

            const jonas = new Person('Jonas', 1991);
            const matilda = new Person('Matilda', 2001);
            const jack = new Person('Jack', 1982);
            <span class="red">the operator new creates a new object, that instantiates the "class" of objects Person, inheriting its properties.</span>

            console.log(jonas instanceof Person);
            //true

        </code></pre>

        <h4>Prototypes</h4>
        <p>Always when an array, object or function is created, they receive a special property called prototype. The
            prototype contains all the methods that are inside that object.</p>
        <pre><code>
            Person.prototype.calcAge = function(){
                console.log(2022 - this.birthYear);
            };

            jonas.calcAge();
            //31
            matilda.calcAge();
            //21
            jack.calcAge();
            //40
            <span class="red">once assigned to the prototype, a function is inherited by all the constructor's children.</span>

            console.log(jonas.__proto__);
            //returns the prototype of the constructor function that ganerated the object jonas

            console.log(jonas.__proto__ === Person.prototype);
            //true

            console.log(Person.prototype.isPrototypeOf(jonas));
            //true

            console.log(Person.prototype.isPrototypeOf(Person));
            //false
            <span class="red">it is only prototype of the child objects</span>

            Person.prototype.species = 'Homo sapiens';
            console.log(jonas.species);
            //'Homo sapiens'

            console.log(jonas.hasOwnProperty('firstName'));
            //true
            console.log(jonas.hasOwnProperty('species'));
            //false
            <span class="red">species is only a property inherited from the prototype of Person, but it is still not directly assigned to the object jonas</span>
        </code></pre>
        <p>All arrays have also a prototype. It's in this prototypes that the array methods lie, just waiting for us to
            use them: .filter(), .fill(), etc.</p>
        <pre><code>
            jonas.__proto__
            <span class="red">prototype inherited from the Person constructor</span>

            jonas.__proto__.__proto__ 
            <span class="red">Object.prototype, general prototype for all objects /  arrays / functions</span>

            jonas.__proto__.__proto__.__proto__
            <span class="red">returns null, because the Object.prototype is the top of the prototype chain.</span>
        </code></pre>
        <pre><code>
            const arr = [3, 4, 3, 5, 3, 4, 4];
            <span class="red">This is equal to write const arr = new Array(3, 4, 3, 5, 3, 4, 4)</span>
            console.log(arr.__proto__);
            <span class="red">returns the prototype inherited by all arrays</span>
            console.log(arr.__proto__ === Array.prototype);
            //true
        </code></pre>
        <p>We can add new methods to all arrays by adding methods to the Array.prototipe object.</p>
        <pre><code>
            Array.prototype.unique = function () {
                return [...new Set(this)];
            };
            console.log(arr.unique());
            //[3, 4, 5]
        </code></pre>

        <h4>ES6 Classes</h4>
        <p>ES6 introduced a new way of creating "classes" in JS. However, it is perfectly acceptable to continue to
            create them using Constructor Functions.</p>
        <pre><code>
            <span class="red">class expression:</span>
            const PersonCl = class {}

            <span class="red">class declaration (BETTER)</span>
            class PersonCl {
                constructor(first, birth) {
                    this.firstName = first;
                    this.birthYear = birth;
                },
                calcAge(){
                    console.log(2022 - this.birthYear);
                }, <span class="red">the method can be inserted inside of the class, no problem</span>
            }

            const jessica = new PersonCl('jessica', 1996);
            jessica.calcAge();
            //26

            <span class="red">Methods can also be added later:</span>
            PersonCl.prototype.greet = function() {
                console.log(`Hey ${this.firstName}`);
            }
            jessica.greet();
            //Hey Jessica
        </code></pre>
        <p>Classes' characteristics:
        <ol>
            <li>Classes are not HOISTED, ie, you can not use them before they are declared on the code.</li>
            <li>Classes are first-class citizens, ie, it is possible to call them into functions and also to return them
                from functions.</li>
            <li>The body of a class is always executed in strict mode.</li>
        </ol>
        </p>

        <h4>Setters and getters</h4>
        <p>These are special ways of defining methods inside of an object or a class. Getters turn a method into a
            property.</p>
        <pre><code>
            <span class="red">Getters and Setters in literal objects:</span>
            
            const account = {
                owner: 'Jonas',
                movements: [200, 530, 120, 300],

                get latest() {
                    return this.movements.slice(-1).pop();
                },

                set latest(mov) {
                    this.movements.push(mov);
                },
            }

            console.log(account.latest); <span class="red">there is no need to call by adding ()</span>
            //300

            account.latest = 50;
            console.log(account.movements);
            //[200, 530, 120, 300, 50]
        </code></pre>
        <pre><code>
            <span class="red">Getters and Setters in classes:</span>
            class PersonCl {
                constructor(first, birth) {
                    this.firstName = first;
                    this.birthYear = birth;
                },
                calcAge(){
                    console.log(2022 - this.birthYear);
                },
                greet(){
                    console.log(`Hey ${this.firstName}`);
                },
                get adultYear() {
                    return this.birthYear + 18;
                },
            }

            const jessica = new PersonCl('Jessica', 1996)
            jessica.calcAge();
            //26
            console.log(jessica.age);
            //2014
        </code></pre>
        <p>Another example (from Jonas lecture 217 (challenges 1 and 2).</p>
        <pre><code>
            1. Use ES6 class to implement a 'Car'. A car has a 'make' and a 'speed' property. The 'speed' property is the current speed of the car in km/h
            2. Implement an 'accelerate' method that will increase the car's speed by 10, and log the new speed to the console
            3. Implementa 'brake' method that will decrease the car's speed by 5,and log the new speed to the console
            4. Add a getter called 'speedUS' which returns the current speed in mi/h (divide by 1.6)
            3. Add a setter called 'speedUS' which sets the current speed in mi/h (but converts it to km/h before storing the value, by multiplying the input by 1.6)
            4. Create a new car and experiment with the 'accelerate' and 'brake' 
            methods, and with the getter and setter.
            
            class CarCl {
                constructor(name, inSpeed) {
                    this.make = name;
                    this.speed = inSpeed;
                }
                accelerate() {
                    console.log(this.speed += 10);
                };
                brake() {
                    console.log(this.speed -= 5);
                };
                get speedUS() {
                    return this.speed / 1.6;
                };
                set speedUS(givenSpeed) {
                    this.speed = givenSpeed * 1.6;
                }
            
            }
            const car3 = new CarCl('Ford', 120);
            
            console.log(ford.speedUS);
            car3.accelerate();
            car3.brake();
            
            ford.speedUS = 50;
            console.log(ford.speed);
        </code></pre>

        <h4>Static methods</h4>
        <p>These are methods that belong to the constructor, and are not inherited by the instances.</p>
        <pre><code>
            For example:
            Array.from(document.querySelectorAll('h1'));
            <span class="red">transform a node list into an array. This method belongs to the Array constructor, and cannot be called like this: arrayx.from()</span>

            Number.parseFloat(12)

            <span class="red">Adding a static method to the Person constructor:</span>
            Person.hey = function(){
                console.log('Hey there!');
                console.log(this);
            };
            Person.hey();
            //Hey there!
            //entire Constructor Function

            <span class="red">Adding a static method to a class:</span>
            class PersonCl {
                constructor(first, birth) {
                    this.firstName = first;
                    this.birthYear = birth;
                },
                <span class="red">Instance methods (will be added to the .prototype property and therefore will be inherited by the instances):</span> 
                calcAge(){
                    console.log(2022 - this.birthYear);
                },
                <span class="red">Static method:</span>
                static hey() {
                    console.log('Hey there!');
                    console.log(this);
                }
            };

            PersonCl.hey();
            //Hey there!
            //entire Class
        </code></pre>

        <h4>Object.create()</h4>
        <p>This is the third (and less used) method to create an object from a prototype.</p>
        <pre><code>
            <span class="red">first, create the prototype:</span>
            const PersonProto = {
                calcAge() {
                    console.log(2022 - this.birthYear);
                },
                init(first, birth){
                    this.firstName = first;
                    this.birthYear = birth;
                } <span class="red">this is a pseudo constructor function used to create the object's properties that are not methods</span>
            };

            <span class="red">then, create a new object containing this prototype:</span>
            const steven = Object.create(PersonProto);
            steven.init('Steven', 2002);
            steven.calcAge();

            console.log(steven.__proto__ === PersonProto);
            //true

            const sarah = Object.create(PersonProto);
            sarah.init('Sarah', 1979);
        </code></pre>
        <h4>Creating child 'classes' using Constructor Function & Inheritance between 'classes'</h4>
        <p>Classes created from another class will also inherit its parent's methods and properties.</p>
        <pre><code>
            const Person = function (first, birth) {
                this.firstName = first;
                this.birthYear = birth;
            };
            Person.prototype.calcAge = function (){
                console.log(2022 - this.birthYear);
            };

            const Student = function (first, birth, course){
                Person.call(this, firstName, birthYear);
                this.course = course;
            };

            Student.prototype = Object.create(Person.prototype); <span class="red">now all methods and properties inside of Person will also work on Student</span>

            Student.prototype.introduce = function(){
                console.log(`My name is ${this.firstName} and I study ${this.course}`);
            };

            const mike = new Student('Mike', 1980, 'Computer Science');
            
            mike.introduce();
            //My name is Mike and I study Computer Science

            <b>mike.calcAge();
            //42</b>
        </code></pre>
        <h4>Creating child 'classes' using ES6 Class keyword</h4>
        <p>This is a easier and more modern way of doing this.</p>
        <pre><code>
            class StudentCl extends PersonCl {
                constructor(first, birth, course) {
                    //Always needs to happen first:
                    super(first, birth);
                    this.course = course;
                }
                introduce(){
                    console.log(`My name is ${this.firstName} and I study ${this.course}`);
                }

                calcAge(){
                    console.log(`I'm ${2022 - this.birthYear} years old, but I feel older`)
                }; <span class="red">this method will "overwrite" the original method in PersonCl, because JS will find it first on the Prototype Chain. This method will <b>shadow</b> the original one.</span>
            }

            const martha = new StudentCl('Martha Jones', 1990, 'Computer Science');
            martha.introduce();
            //My name is Martha Jones and I study Computer Science.
            martha.calcAge();
            //I'm 32 years old, but I feel older
        </code></pre>

        <h4>Creating child 'classes' using Object.create()</h4>
        <p>Although more simple, this method is actually not very often seen in the real world.</p>
        <pre><code>
            const PersonProto = {
                calcAge() {
                    console.log(2022 - this.birthYear);
                },
                init(first, birth){
                    this.firstName = first;
                    this.birthYear = birth;
                }
            };

            const steven = Object.create(PersonProto);

            const StudentProto = Object.create(PersonProto);
            StudentProto.init = function(first, birth, course){
                PersonProto.init.call(this, first, birth);
                this.course = course;
            };

            StudentProto.introduce = function(){
                console.log(`My name is ${this.firstName} and I study ${this.course}`)
            };

            const jay = Object.create(StudentProto);
            jay.init('Jay', 1991, 'Computer Science');
            jay.introduce();
            jay.calcAge();
        </code></pre>

        <h4>Recap: Creating 'class' using ES6, adding methods</h4>
        <pre><code>
            class Account {
                constructor(owner, currency, pin){
                    this.owner = owner;
                    this.currency = currency;
                    this.pin = pin;
                    this.movements = [];
                    this.locale = navigator.language;
                    console.log(`Thanks for opening an account, ${this.owner`});
                }
                <span class="red">here begins the API (public interface), ie, the methods which are accesible outside of the object:</span>
                deposit(val) {
                    this.movement.push(val);
                }
                withdraw(val) {
                    this.deposit(-val);
                }
            }

            const acc1 = new Account('Jonas', 'EUR', 1111);
            acc.deposit(250);
            acc.withdraw(140);
        </code></pre>
        <h4>Encapsulation: protected properties and methods</h4>
        <p>Sometimes we don't want some properties or methods to be changed by functions that are outside of the object.
            To add _ before the name of these methods/properties is a convention to signal it. However, it doesn't
            prevent them from be changed, it is just a signaling convention.</p>
        <pre><code>
            class Account {
                constructor(owner, currency, pin){
                    this.owner = owner;
                    this.currency = currency;
                    this._pin = pin; <span class="red">protected</span>
                    this._movements = []; <span class="red">protected</span>
                    this.locale = navigator.language;
                    console.log(`Thanks for opening an account, ${this.owner`});
                }
                deposit(val) {
                    this._movement.push(val);
                }
                withdraw(val) {
                    this.deposit(-val);
                }
                getMovements(){
                    return this._movements;
                } <span class="red">this method was written specially for the purpose of getting access to the _movements array from outside of the object.</span>
            }

            acc1.getMovements();
            //[250, -140]
        </code></pre>
        <h4>Encapsulation: protect properties and methods using Private Class Fields and Methods</h4>
        <p>These JS features, as for 2022, are still under implementation and for now are only available in Chrome.</p>
        <pre><code>
            1) Public fields
            2) Private fields 
            3) Public methods  = Public interface
            4) Private methods 
            
            class Account {
                <span class="red">1) Public fields:</span>
                locale = navigator.language;
                
                <span class="red">2) Private fields:</span>
                #movements = [];
                #pin; <span class="red">this property is only defined, because it need its value to be taken from the constructor paramenter.</span>
                
                constructor(owner, currency, pin){
                    this.owner = owner;
                    this.currency = currency;
                    this.#pin = pin; 
                    console.log(`Thanks for opening an account, ${this.owner`});
                }
                <span class="red">3) Public interface = Public methods</span>
                deposit(val) {
                    this.#movement.push(val);
                }
                withdraw(val) {
                    this.deposit(-val);
                }
                getMovements(){
                    return this.#movements;
                } <span class="red">this method was written specially for the purpose of getting access to the #movements array from outside of the object.</span>

                <span class="red">4) Private methods:</span>
                #approveLoan(val){
                    return true;
                }
            }
        </code></pre>
        <h4>Chaining methods when calling instances' methods</h4>
        <p>In order to be possible to chain methods when calling instances' methods, the class' methods need to return
            'this', so that there won't be errors when chaining the methods.</p>
        <pre><code>
            class Account {
                locale = navigator.language;
                
                #movements = [];
                #pin;

                constructor(owner, currency, pin){
                    this.owner = owner;
                    this.currency = currency;
                    this.#pin = pin; 
                    console.log(`Thanks for opening an account, ${this.owner`});
                }
                deposit(val) {
                    this.#movement.push(val);
                    return this;
                }
                withdraw(val) {
                    this.deposit(-val);
                    return this;
                }
                getMovements(){
                    return this.#movements;
                } 
            }

            acc1.deposit(300).deposit(500).withdraw(100).withdraw(100);
            
        </code></pre>




        <script src="app.js"></script>



        <!-- JS Code to enable bootstrap -->
        <!-- <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
            integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
            crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js"
            integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
            crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js"
            integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
            crossorigin="anonymous"></script> -->


</body>

</html>